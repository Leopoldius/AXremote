# 1 "..\\COMMON\\easyax5043.c"
# 1 "<built-in>"
# 1 "<command line>"
# 1 "..\\COMMON\\easyax5043.c"
# 30 "..\\COMMON\\easyax5043.c"
# 1 "..\\COMMON\\/easyax5043.h" 1
# 34 "..\\COMMON\\/easyax5043.h"
# 1 "..\\COMMON\\/axradio.h" 1
# 34 "..\\COMMON\\/axradio.h"
# 1 "C://Program Files (x86)//AXSEM//AXSDB//libmf//include/libmftypes.h" 1
# 54 "C://Program Files (x86)//AXSEM//AXSDB//libmf//include/libmftypes.h"
typedef signed char int8_t;
typedef signed int int16_t;
typedef signed long int32_t;
typedef unsigned char uint8_t;
typedef unsigned int uint16_t;
typedef unsigned long uint32_t;




extern void delay(uint16_t us) __reentrant __naked;




extern uint16_t __data random_seed;
extern uint16_t random(void);





#pragma callee_saves hweight8,hweight16,hweight32
#pragma callee_saves signextend12,signextend16,signextend20,signextend24
extern int32_t signextend12(int16_t x) __reentrant __naked;
extern int32_t signextend16(int16_t x) __reentrant __naked;
extern int32_t signextend20(int32_t x) __reentrant __naked;
extern int32_t signextend24(int32_t x) __reentrant __naked;






extern uint8_t hweight8(uint8_t x) __reentrant;
extern uint8_t hweight16(uint16_t x) __reentrant;
extern uint8_t hweight32(uint32_t x) __reentrant;




#pragma callee_saves signedlimit16,checksignedlimit16,signedlimit32,checksignedlimit32
extern int16_t signedlimit16(int16_t x, int16_t lim) __reentrant __naked;
extern uint8_t checksignedlimit16(int16_t x, int16_t lim) __reentrant __naked;
extern int32_t signedlimit32(int32_t x, int32_t lim) __reentrant __naked;
extern uint8_t checksignedlimit32(int32_t x, int32_t lim) __reentrant __naked;
# 111 "C://Program Files (x86)//AXSEM//AXSDB//libmf//include/libmftypes.h"
extern uint8_t rev8(uint8_t x) __reentrant;
# 126 "C://Program Files (x86)//AXSEM//AXSDB//libmf//include/libmftypes.h"
#pragma callee_saves wtimer_standby,enter_standby,enter_sleep,enter_deepsleep

extern void wtimer_standby(void) __reentrant;
extern void enter_standby(void) __reentrant;
extern void enter_sleep(void) __reentrant;

extern void enter_sleep_cont(void) __reentrant;

extern void enter_deepsleep(void) __reentrant;
extern void reset_cpu(void) __reentrant;
extern void turn_off_xosc(void) __reentrant;
extern void turn_off_lpxosc(void) __reentrant;
# 35 "..\\COMMON\\/axradio.h" 2
# 79 "..\\COMMON\\/axradio.h"
struct axradio_address {
    uint8_t addr[4];
};

struct axradio_address_mask {
    uint8_t addr[4];
    uint8_t mask[4];
};

struct axradio_status {
    uint8_t status;
    uint8_t error;
    uint32_t time;

    union {

        struct axradio_status_receive {
            struct axradio_status_receive_phy {
                int16_t rssi;
                int32_t offset;
                int16_t timeoffset;
                int16_t period;
            } phy;
            struct axradio_status_receive_mac {
                uint8_t remoteaddr[4];
                uint8_t localaddr[4];
                const __xdata uint8_t *raw;
            } mac;
            const __xdata uint8_t *pktdata;
            uint16_t pktlen;
        } rx;


        struct axradio_status_channelstate {
            int16_t rssi;
            uint8_t busy;
        } cs;
    } u;
};

extern uint8_t axradio_init(void);
extern uint8_t axradio_cansleep(void) __reentrant;
extern uint8_t axradio_set_mode(uint8_t mode);
extern uint8_t axradio_get_mode(void);
extern uint8_t axradio_set_channel(uint8_t chnum);
extern uint8_t axradio_get_channel(void);
extern uint8_t axradio_get_pllrange(void);
extern uint8_t axradio_get_pllrange_tx(void);
extern void axradio_set_local_address(const struct axradio_address_mask *addr);
extern void axradio_get_local_address(struct axradio_address_mask *addr);
extern void axradio_set_default_remote_address(const struct axradio_address *addr);
extern void axradio_get_default_remote_address(struct axradio_address *addr);
extern uint8_t axradio_set_freqoffset(int32_t offs);
extern int32_t axradio_get_freqoffset(void);
extern int32_t axradio_conv_freq_tohz(int32_t f) __reentrant;
extern int32_t axradio_conv_freq_fromhz(int32_t f) __reentrant;
extern int32_t axradio_conv_timeinterval_totimer0(int32_t dt) __reentrant;
extern uint32_t axradio_conv_time_totimer0(uint32_t dt) __reentrant;
extern uint8_t axradio_transmit(const struct axradio_address *addr, const uint8_t *pkt, uint16_t pktlen);
extern void axradio_statuschange(struct axradio_status __xdata *st);
extern uint8_t axradio_agc_freeze(void);
extern uint8_t axradio_agc_thaw(void);

extern const uint8_t __code axradio_framing_maclen;
extern const uint8_t __code axradio_framing_addrlen;




extern void axradio_isr(void) __interrupt 4;
# 35 "..\\COMMON\\/easyax5043.h" 2

# 1 "C://Program Files (x86)//AXSEM//AXSDB//libmf//include/ax8052f143.h" 1
# 38 "C://Program Files (x86)//AXSEM//AXSDB//libmf//include/ax8052f143.h"
# 1 "C://Program Files (x86)//AXSEM//AXSDB//libmf//include/axcompiler.h" 1
# 39 "C://Program Files (x86)//AXSEM//AXSDB//libmf//include/ax8052f143.h" 2



__sfr __at(0xE0) ACC ;
__sbit __at(0xE0 +0) ACC_0 ;
__sbit __at(0xE0 +1) ACC_1 ;
__sbit __at(0xE0 +2) ACC_2 ;
__sbit __at(0xE0 +3) ACC_3 ;
__sbit __at(0xE0 +4) ACC_4 ;
__sbit __at(0xE0 +5) ACC_5 ;
__sbit __at(0xE0 +6) ACC_6 ;
__sbit __at(0xE0 +7) ACC_7 ;
__sfr __at(0xF0) B ;
__sbit __at(0xF0 +0) B_0 ;
__sbit __at(0xF0 +1) B_1 ;
__sbit __at(0xF0 +2) B_2 ;
__sbit __at(0xF0 +3) B_3 ;
__sbit __at(0xF0 +4) B_4 ;
__sbit __at(0xF0 +5) B_5 ;
__sbit __at(0xF0 +6) B_6 ;
__sbit __at(0xF0 +7) B_7 ;
__sfr __at(0x83) DPH ;
__sfr __at(0x85) DPH1 ;
__sfr __at(0x82) DPL ;
__sfr __at(0x84) DPL1 ;
__sfr16 __at(((0x82 +1U)<<8) | 0x82) DPTR0 ;
__sfr16 __at(((0x84 +1U)<<8) | 0x84) DPTR1 ;
__sfr __at(0x86) DPS ;
__sfr __at(0xA0) E2IE ;
__sbit __at(0xA0 +0) E2IE_0 ;
__sbit __at(0xA0 +1) E2IE_1 ;
__sbit __at(0xA0 +2) E2IE_2 ;
__sbit __at(0xA0 +3) E2IE_3 ;
__sbit __at(0xA0 +4) E2IE_4 ;
__sbit __at(0xA0 +5) E2IE_5 ;
__sbit __at(0xA0 +6) E2IE_6 ;
__sbit __at(0xA0 +7) E2IE_7 ;
__sfr __at(0xC0) E2IP ;
__sbit __at(0xC0 +0) E2IP_0 ;
__sbit __at(0xC0 +1) E2IP_1 ;
__sbit __at(0xC0 +2) E2IP_2 ;
__sbit __at(0xC0 +3) E2IP_3 ;
__sbit __at(0xC0 +4) E2IP_4 ;
__sbit __at(0xC0 +5) E2IP_5 ;
__sbit __at(0xC0 +6) E2IP_6 ;
__sbit __at(0xC0 +7) E2IP_7 ;
__sfr __at(0x98) EIE ;
__sbit __at(0x98 +0) EIE_0 ;
__sbit __at(0x98 +1) EIE_1 ;
__sbit __at(0x98 +2) EIE_2 ;
__sbit __at(0x98 +3) EIE_3 ;
__sbit __at(0x98 +4) EIE_4 ;
__sbit __at(0x98 +5) EIE_5 ;
__sbit __at(0x98 +6) EIE_6 ;
__sbit __at(0x98 +7) EIE_7 ;
__sfr __at(0xB0) EIP ;
__sbit __at(0xB0 +0) EIP_0 ;
__sbit __at(0xB0 +1) EIP_1 ;
__sbit __at(0xB0 +2) EIP_2 ;
__sbit __at(0xB0 +3) EIP_3 ;
__sbit __at(0xB0 +4) EIP_4 ;
__sbit __at(0xB0 +5) EIP_5 ;
__sbit __at(0xB0 +6) EIP_6 ;
__sbit __at(0xB0 +7) EIP_7 ;
__sfr __at(0xA8) IE ;
__sbit __at(0xA8 +0) IE_0 ;
__sbit __at(0xA8 +1) IE_1 ;
__sbit __at(0xA8 +2) IE_2 ;
__sbit __at(0xA8 +3) IE_3 ;
__sbit __at(0xA8 +4) IE_4 ;
__sbit __at(0xA8 +5) IE_5 ;
__sbit __at(0xA8 +6) IE_6 ;
__sbit __at(0xA8 +7) IE_7 ;
__sbit __at(0xA8 +7) EA ;
__sfr __at(0xB8) IP ;
__sbit __at(0xB8 +0) IP_0 ;
__sbit __at(0xB8 +1) IP_1 ;
__sbit __at(0xB8 +2) IP_2 ;
__sbit __at(0xB8 +3) IP_3 ;
__sbit __at(0xB8 +4) IP_4 ;
__sbit __at(0xB8 +5) IP_5 ;
__sbit __at(0xB8 +6) IP_6 ;
__sbit __at(0xB8 +7) IP_7 ;
__sfr __at(0x87) PCON ;
__sfr __at(0xD0) PSW ;
__sbit __at(0xD0 +0) P ;
__sbit __at(0xD0 +1) F1 ;
__sbit __at(0xD0 +2) OV ;
__sbit __at(0xD0 +3) RS0 ;
__sbit __at(0xD0 +4) RS1 ;
__sbit __at(0xD0 +5) F0 ;
__sbit __at(0xD0 +6) AC ;
__sbit __at(0xD0 +7) CY ;
__sfr __at(0x81) SP ;
__sfr __at(0xD9) XPAGE ;
__sfr __at(0xD9) _XPAGE ;
__sfr __at(0xCA) ADCCH0CONFIG ;
__sfr __at(0xCB) ADCCH1CONFIG ;
__sfr __at(0xD2) ADCCH2CONFIG ;
__sfr __at(0xD3) ADCCH3CONFIG ;
__sfr __at(0xD1) ADCCLKSRC ;
__sfr __at(0xC9) ADCCONV ;
__sfr __at(0xE1) ANALOGCOMP ;
__sfr __at(0xC6) CLKCON ;
__sfr __at(0xC7) CLKSTAT ;
__sfr __at(0x97) CODECONFIG ;
__sfr __at(0xE3) DBGLNKBUF ;
__sfr __at(0xE2) DBGLNKSTAT ;
__sfr __at(0x89) DIRA ;
__sfr __at(0x8A) DIRB ;
__sfr __at(0x8B) DIRC ;
__sfr __at(0x8E) DIRR ;
__sfr __at(0xC8) PINA ;
__sbit __at(0xC8 +0) PINA_0 ;
__sbit __at(0xC8 +1) PINA_1 ;
__sbit __at(0xC8 +2) PINA_2 ;
__sbit __at(0xC8 +3) PINA_3 ;
__sbit __at(0xC8 +4) PINA_4 ;
__sbit __at(0xC8 +5) PINA_5 ;
__sbit __at(0xC8 +6) PINA_6 ;
__sbit __at(0xC8 +7) PINA_7 ;
__sfr __at(0xE8) PINB ;
__sbit __at(0xE8 +0) PINB_0 ;
__sbit __at(0xE8 +1) PINB_1 ;
__sbit __at(0xE8 +2) PINB_2 ;
__sbit __at(0xE8 +3) PINB_3 ;
__sbit __at(0xE8 +4) PINB_4 ;
__sbit __at(0xE8 +5) PINB_5 ;
__sbit __at(0xE8 +6) PINB_6 ;
__sbit __at(0xE8 +7) PINB_7 ;
__sfr __at(0xF8) PINC ;
__sbit __at(0xF8 +0) PINC_0 ;
__sbit __at(0xF8 +1) PINC_1 ;
__sbit __at(0xF8 +2) PINC_2 ;
__sbit __at(0xF8 +3) PINC_3 ;
__sbit __at(0xF8 +4) PINC_4 ;
__sbit __at(0xF8 +5) PINC_5 ;
__sbit __at(0xF8 +6) PINC_6 ;
__sbit __at(0xF8 +7) PINC_7 ;
__sfr __at(0x8D) PINR ;
__sfr __at(0x80) PORTA ;
__sbit __at(0x80 +0) PORTA_0 ;
__sbit __at(0x80 +1) PORTA_1 ;
__sbit __at(0x80 +2) PORTA_2 ;
__sbit __at(0x80 +3) PORTA_3 ;
__sbit __at(0x80 +4) PORTA_4 ;
__sbit __at(0x80 +5) PORTA_5 ;
__sbit __at(0x80 +6) PORTA_6 ;
__sbit __at(0x80 +7) PORTA_7 ;
__sfr __at(0x88) PORTB ;
__sbit __at(0x88 +0) PORTB_0 ;
__sbit __at(0x88 +1) PORTB_1 ;
__sbit __at(0x88 +2) PORTB_2 ;
__sbit __at(0x88 +3) PORTB_3 ;
__sbit __at(0x88 +4) PORTB_4 ;
__sbit __at(0x88 +5) PORTB_5 ;
__sbit __at(0x88 +6) PORTB_6 ;
__sbit __at(0x88 +7) PORTB_7 ;
__sfr __at(0x90) PORTC ;
__sbit __at(0x90 +0) PORTC_0 ;
__sbit __at(0x90 +1) PORTC_1 ;
__sbit __at(0x90 +2) PORTC_2 ;
__sbit __at(0x90 +3) PORTC_3 ;
__sbit __at(0x90 +4) PORTC_4 ;
__sbit __at(0x90 +5) PORTC_5 ;
__sbit __at(0x90 +6) PORTC_6 ;
__sbit __at(0x90 +7) PORTC_7 ;
__sfr __at(0x8C) PORTR ;
__sfr __at(0xCE) IC0CAPT0 ;
__sfr __at(0xCF) IC0CAPT1 ;
__sfr16 __at(((0xCE +1U)<<8) | 0xCE) IC0CAPT ;
__sfr __at(0xCC) IC0MODE ;
__sfr __at(0xCD) IC0STATUS ;
__sfr __at(0xD6) IC1CAPT0 ;
__sfr __at(0xD7) IC1CAPT1 ;
__sfr16 __at(((0xD6 +1U)<<8) | 0xD6) IC1CAPT ;
__sfr __at(0xD4) IC1MODE ;
__sfr __at(0xD5) IC1STATUS ;
__sfr __at(0x92) NVADDR0 ;
__sfr __at(0x93) NVADDR1 ;
__sfr16 __at(((0x92 +1U)<<8) | 0x92) NVADDR ;
__sfr __at(0x94) NVDATA0 ;
__sfr __at(0x95) NVDATA1 ;
__sfr16 __at(((0x94 +1U)<<8) | 0x94) NVDATA ;
__sfr __at(0x96) NVKEY ;
__sfr __at(0x91) NVSTATUS ;
__sfr __at(0xBC) OC0COMP0 ;
__sfr __at(0xBD) OC0COMP1 ;
__sfr16 __at(((0xBC +1U)<<8) | 0xBC) OC0COMP ;
__sfr __at(0xB9) OC0MODE ;
__sfr __at(0xBA) OC0PIN ;
__sfr __at(0xBB) OC0STATUS ;
__sfr __at(0xC4) OC1COMP0 ;
__sfr __at(0xC5) OC1COMP1 ;
__sfr16 __at(((0xC4 +1U)<<8) | 0xC4) OC1COMP ;
__sfr __at(0xC1) OC1MODE ;
__sfr __at(0xC2) OC1PIN ;
__sfr __at(0xC3) OC1STATUS ;
__sfr __at(0xB1) RADIOACC ;
__sfr __at(0xB3) RADIOADDR0 ;
__sfr __at(0xB2) RADIOADDR1 ;
__sfr16 __at(0xB2B3) RADIOADDR ;
__sfr __at(0xB7) RADIODATA0 ;
__sfr __at(0xB6) RADIODATA1 ;
__sfr __at(0xB5) RADIODATA2 ;
__sfr __at(0xB4) RADIODATA3 ;
__sfr32 __at(0xB4B5B6B7) RADIODATA ;
__sfr __at(0xBE) RADIOSTAT0 ;
__sfr __at(0xBF) RADIOSTAT1 ;
__sfr16 __at(((0xBE +1U)<<8) | 0xBE) RADIOSTAT ;
__sfr __at(0xDF) SPCLKSRC ;
__sfr __at(0xDC) SPMODE ;
__sfr __at(0xDE) SPSHREG ;
__sfr __at(0xDD) SPSTATUS ;
__sfr __at(0x9A) T0CLKSRC ;
__sfr __at(0x9C) T0CNT0 ;
__sfr __at(0x9D) T0CNT1 ;
__sfr16 __at(((0x9C +1U)<<8) | 0x9C) T0CNT ;
__sfr __at(0x99) T0MODE ;
__sfr __at(0x9E) T0PERIOD0 ;
__sfr __at(0x9F) T0PERIOD1 ;
__sfr16 __at(((0x9E +1U)<<8) | 0x9E) T0PERIOD ;
__sfr __at(0x9B) T0STATUS ;
__sfr __at(0xA2) T1CLKSRC ;
__sfr __at(0xA4) T1CNT0 ;
__sfr __at(0xA5) T1CNT1 ;
__sfr16 __at(((0xA4 +1U)<<8) | 0xA4) T1CNT ;
__sfr __at(0xA1) T1MODE ;
__sfr __at(0xA6) T1PERIOD0 ;
__sfr __at(0xA7) T1PERIOD1 ;
__sfr16 __at(((0xA6 +1U)<<8) | 0xA6) T1PERIOD ;
__sfr __at(0xA3) T1STATUS ;
__sfr __at(0xAA) T2CLKSRC ;
__sfr __at(0xAC) T2CNT0 ;
__sfr __at(0xAD) T2CNT1 ;
__sfr16 __at(((0xAC +1U)<<8) | 0xAC) T2CNT ;
__sfr __at(0xA9) T2MODE ;
__sfr __at(0xAE) T2PERIOD0 ;
__sfr __at(0xAF) T2PERIOD1 ;
__sfr16 __at(((0xAE +1U)<<8) | 0xAE) T2PERIOD ;
__sfr __at(0xAB) T2STATUS ;
__sfr __at(0xE4) U0CTRL ;
__sfr __at(0xE7) U0MODE ;
__sfr __at(0xE6) U0SHREG ;
__sfr __at(0xE5) U0STATUS ;
__sfr __at(0xEC) U1CTRL ;
__sfr __at(0xEF) U1MODE ;
__sfr __at(0xEE) U1SHREG ;
__sfr __at(0xED) U1STATUS ;
__sfr __at(0xDA) WDTCFG ;
__sfr __at(0xDB) WDTRESET ;
__sfr __at(0xF1) WTCFGA ;
__sfr __at(0xF9) WTCFGB ;
__sfr __at(0xF2) WTCNTA0 ;
__sfr __at(0xF3) WTCNTA1 ;
__sfr16 __at(((0xF2 +1U)<<8) | 0xF2) WTCNTA ;
__sfr __at(0xFA) WTCNTB0 ;
__sfr __at(0xFB) WTCNTB1 ;
__sfr16 __at(((0xFA +1U)<<8) | 0xFA) WTCNTB ;
__sfr __at(0xEB) WTCNTR1 ;
__sfr __at(0xF4) WTEVTA0 ;
__sfr __at(0xF5) WTEVTA1 ;
__sfr16 __at(((0xF4 +1U)<<8) | 0xF4) WTEVTA ;
__sfr __at(0xF6) WTEVTB0 ;
__sfr __at(0xF7) WTEVTB1 ;
__sfr16 __at(((0xF6 +1U)<<8) | 0xF6) WTEVTB ;
__sfr __at(0xFC) WTEVTC0 ;
__sfr __at(0xFD) WTEVTC1 ;
__sfr16 __at(((0xFC +1U)<<8) | 0xFC) WTEVTC ;
__sfr __at(0xFE) WTEVTD0 ;
__sfr __at(0xFF) WTEVTD1 ;
__sfr16 __at(((0xFE +1U)<<8) | 0xFE) WTEVTD ;
__sfr __at(0xE9) WTIRQEN ;
__sfr __at(0xEA) WTSTAT ;






__xdata volatile unsigned char __at(0x7020) ADCCH0VAL0 ;
__xdata volatile unsigned char __at(0x7021) ADCCH0VAL1 ;
__xdata volatile unsigned short __at(0x7020) ADCCH0VAL ;
__xdata volatile unsigned char __at(0x7022) ADCCH1VAL0 ;
__xdata volatile unsigned char __at(0x7023) ADCCH1VAL1 ;
__xdata volatile unsigned short __at(0x7022) ADCCH1VAL ;
__xdata volatile unsigned char __at(0x7024) ADCCH2VAL0 ;
__xdata volatile unsigned char __at(0x7025) ADCCH2VAL1 ;
__xdata volatile unsigned short __at(0x7024) ADCCH2VAL ;
__xdata volatile unsigned char __at(0x7026) ADCCH3VAL0 ;
__xdata volatile unsigned char __at(0x7027) ADCCH3VAL1 ;
__xdata volatile unsigned short __at(0x7026) ADCCH3VAL ;
__xdata volatile unsigned char __at(0x7028) ADCTUNE0 ;
__xdata volatile unsigned char __at(0x7029) ADCTUNE1 ;
__xdata volatile unsigned char __at(0x702A) ADCTUNE2 ;
__xdata volatile unsigned char __at(0x7010) DMA0ADDR0 ;
__xdata volatile unsigned char __at(0x7011) DMA0ADDR1 ;
__xdata volatile unsigned short __at(0x7010) DMA0ADDR ;
__xdata volatile unsigned char __at(0x7014) DMA0CONFIG ;
__xdata volatile unsigned char __at(0x7012) DMA1ADDR0 ;
__xdata volatile unsigned char __at(0x7013) DMA1ADDR1 ;
__xdata volatile unsigned short __at(0x7012) DMA1ADDR ;
__xdata volatile unsigned char __at(0x7015) DMA1CONFIG ;
__xdata volatile unsigned char __at(0x7070) FRCOSCCONFIG ;
__xdata volatile unsigned char __at(0x7071) FRCOSCCTRL ;
__xdata volatile unsigned char __at(0x7076) FRCOSCFREQ0 ;
__xdata volatile unsigned char __at(0x7077) FRCOSCFREQ1 ;
__xdata volatile unsigned short __at(0x7076) FRCOSCFREQ ;
__xdata volatile unsigned char __at(0x7072) FRCOSCKFILT0 ;
__xdata volatile unsigned char __at(0x7073) FRCOSCKFILT1 ;
__xdata volatile unsigned short __at(0x7072) FRCOSCKFILT ;
__xdata volatile unsigned char __at(0x7078) FRCOSCPER0 ;
__xdata volatile unsigned char __at(0x7079) FRCOSCPER1 ;
__xdata volatile unsigned short __at(0x7078) FRCOSCPER ;
__xdata volatile unsigned char __at(0x7074) FRCOSCREF0 ;
__xdata volatile unsigned char __at(0x7075) FRCOSCREF1 ;
__xdata volatile unsigned short __at(0x7074) FRCOSCREF ;
__xdata volatile unsigned char __at(0x7007) ANALOGA ;
__xdata volatile unsigned char __at(0x700C) GPIOENABLE ;
__xdata volatile unsigned char __at(0x7003) EXTIRQ ;
__xdata volatile unsigned char __at(0x7000) INTCHGA ;
__xdata volatile unsigned char __at(0x7001) INTCHGB ;
__xdata volatile unsigned char __at(0x7002) INTCHGC ;
__xdata volatile unsigned char __at(0x7008) PALTA ;
__xdata volatile unsigned char __at(0x7009) PALTB ;
__xdata volatile unsigned char __at(0x700A) PALTC ;
__xdata volatile unsigned char __at(0x7046) PALTRADIO ;
__xdata volatile unsigned char __at(0x7004) PINCHGA ;
__xdata volatile unsigned char __at(0x7005) PINCHGB ;
__xdata volatile unsigned char __at(0x7006) PINCHGC ;
__xdata volatile unsigned char __at(0x700B) PINSEL ;
__xdata volatile unsigned char __at(0x7060) LPOSCCONFIG ;
__xdata volatile unsigned char __at(0x7066) LPOSCFREQ0 ;
__xdata volatile unsigned char __at(0x7067) LPOSCFREQ1 ;
__xdata volatile unsigned short __at(0x7066) LPOSCFREQ ;
__xdata volatile unsigned char __at(0x7062) LPOSCKFILT0 ;
__xdata volatile unsigned char __at(0x7063) LPOSCKFILT1 ;
__xdata volatile unsigned short __at(0x7062) LPOSCKFILT ;
__xdata volatile unsigned char __at(0x7068) LPOSCPER0 ;
__xdata volatile unsigned char __at(0x7069) LPOSCPER1 ;
__xdata volatile unsigned short __at(0x7068) LPOSCPER ;
__xdata volatile unsigned char __at(0x7064) LPOSCREF0 ;
__xdata volatile unsigned char __at(0x7065) LPOSCREF1 ;
__xdata volatile unsigned short __at(0x7064) LPOSCREF ;
__xdata volatile unsigned char __at(0x7054) LPXOSCGM ;
__xdata volatile unsigned char __at(0x7F01) MISCCTRL ;
__xdata volatile unsigned char __at(0x7053) OSCCALIB ;
__xdata volatile unsigned char __at(0x7050) OSCFORCERUN ;
__xdata volatile unsigned char __at(0x7052) OSCREADY ;
__xdata volatile unsigned char __at(0x7051) OSCRUN ;
__xdata volatile unsigned char __at(0x7040) RADIOFDATAADDR0 ;
__xdata volatile unsigned char __at(0x7041) RADIOFDATAADDR1 ;
__xdata volatile unsigned short __at(0x7040) RADIOFDATAADDR ;
__xdata volatile unsigned char __at(0x7042) RADIOFSTATADDR0 ;
__xdata volatile unsigned char __at(0x7043) RADIOFSTATADDR1 ;
__xdata volatile unsigned short __at(0x7042) RADIOFSTATADDR ;
__xdata volatile unsigned char __at(0x7044) RADIOMUX ;
__xdata volatile unsigned char __at(0x7084) SCRATCH0 ;
__xdata volatile unsigned char __at(0x7085) SCRATCH1 ;
__xdata volatile unsigned char __at(0x7086) SCRATCH2 ;
__xdata volatile unsigned char __at(0x7087) SCRATCH3 ;
__xdata volatile unsigned char __at(0x7F00) SILICONREV ;
__xdata volatile unsigned char __at(0x7F19) XTALAMPL ;
__xdata volatile unsigned char __at(0x7F18) XTALOSC ;
__xdata volatile unsigned char __at(0x7F1A) XTALREADY ;




__xdata volatile unsigned short __at(0x3F82) XDPTR0 ;
__xdata volatile unsigned short __at(0x3F84) XDPTR1 ;
__xdata volatile unsigned char __at(0x3FA8) XIE ;
__xdata volatile unsigned char __at(0x3FB8) XIP ;
__xdata volatile unsigned char __at(0x3F87) XPCON ;
__xdata volatile unsigned char __at(0x3FCA) XADCCH0CONFIG ;
__xdata volatile unsigned char __at(0x3FCB) XADCCH1CONFIG ;
__xdata volatile unsigned char __at(0x3FD2) XADCCH2CONFIG ;
__xdata volatile unsigned char __at(0x3FD3) XADCCH3CONFIG ;
__xdata volatile unsigned char __at(0x3FD1) XADCCLKSRC ;
__xdata volatile unsigned char __at(0x3FC9) XADCCONV ;
__xdata volatile unsigned char __at(0x3FE1) XANALOGCOMP ;
__xdata volatile unsigned char __at(0x3FC6) XCLKCON ;
__xdata volatile unsigned char __at(0x3FC7) XCLKSTAT ;
__xdata volatile unsigned char __at(0x3F97) XCODECONFIG ;
__xdata volatile unsigned char __at(0x3FE3) XDBGLNKBUF ;
__xdata volatile unsigned char __at(0x3FE2) XDBGLNKSTAT ;
__xdata volatile unsigned char __at(0x3F89) XDIRA ;
__xdata volatile unsigned char __at(0x3F8A) XDIRB ;
__xdata volatile unsigned char __at(0x3F8B) XDIRC ;
__xdata volatile unsigned char __at(0x3F8E) XDIRR ;
__xdata volatile unsigned char __at(0x3FC8) XPINA ;
__xdata volatile unsigned char __at(0x3FE8) XPINB ;
__xdata volatile unsigned char __at(0x3FF8) XPINC ;
__xdata volatile unsigned char __at(0x3F8D) XPINR ;
__xdata volatile unsigned char __at(0x3F80) XPORTA ;
__xdata volatile unsigned char __at(0x3F88) XPORTB ;
__xdata volatile unsigned char __at(0x3F90) XPORTC ;
__xdata volatile unsigned char __at(0x3F8C) XPORTR ;
__xdata volatile unsigned char __at(0x3FCE) XIC0CAPT0 ;
__xdata volatile unsigned char __at(0x3FCF) XIC0CAPT1 ;
__xdata volatile unsigned short __at(0x3FCE) XIC0CAPT ;
__xdata volatile unsigned char __at(0x3FCC) XIC0MODE ;
__xdata volatile unsigned char __at(0x3FCD) XIC0STATUS ;
__xdata volatile unsigned char __at(0x3FD6) XIC1CAPT0 ;
__xdata volatile unsigned char __at(0x3FD7) XIC1CAPT1 ;
__xdata volatile unsigned short __at(0x3FD6) XIC1CAPT ;
__xdata volatile unsigned char __at(0x3FD4) XIC1MODE ;
__xdata volatile unsigned char __at(0x3FD5) XIC1STATUS ;
__xdata volatile unsigned char __at(0x3F92) XNVADDR0 ;
__xdata volatile unsigned char __at(0x3F93) XNVADDR1 ;
__xdata volatile unsigned short __at(0x3F92) XNVADDR ;
__xdata volatile unsigned char __at(0x3F94) XNVDATA0 ;
__xdata volatile unsigned char __at(0x3F95) XNVDATA1 ;
__xdata volatile unsigned short __at(0x3F94) XNVDATA ;
__xdata volatile unsigned char __at(0x3F96) XNVKEY ;
__xdata volatile unsigned char __at(0x3F91) XNVSTATUS ;
__xdata volatile unsigned char __at(0x3FBC) XOC0COMP0 ;
__xdata volatile unsigned char __at(0x3FBD) XOC0COMP1 ;
__xdata volatile unsigned short __at(0x3FBC) XOC0COMP ;
__xdata volatile unsigned char __at(0x3FB9) XOC0MODE ;
__xdata volatile unsigned char __at(0x3FBA) XOC0PIN ;
__xdata volatile unsigned char __at(0x3FBB) XOC0STATUS ;
__xdata volatile unsigned char __at(0x3FC4) XOC1COMP0 ;
__xdata volatile unsigned char __at(0x3FC5) XOC1COMP1 ;
__xdata volatile unsigned short __at(0x3FC4) XOC1COMP ;
__xdata volatile unsigned char __at(0x3FC1) XOC1MODE ;
__xdata volatile unsigned char __at(0x3FC2) XOC1PIN ;
__xdata volatile unsigned char __at(0x3FC3) XOC1STATUS ;
__xdata volatile unsigned char __at(0x3FB1) XRADIOACC ;
__xdata volatile unsigned char __at(0x3FB3) XRADIOADDR0 ;
__xdata volatile unsigned char __at(0x3FB2) XRADIOADDR1 ;
__xdata volatile unsigned char __at(0x3FB7) XRADIODATA0 ;
__xdata volatile unsigned char __at(0x3FB6) XRADIODATA1 ;
__xdata volatile unsigned char __at(0x3FB5) XRADIODATA2 ;
__xdata volatile unsigned char __at(0x3FB4) XRADIODATA3 ;
__xdata volatile unsigned char __at(0x3FBE) XRADIOSTAT0 ;
__xdata volatile unsigned char __at(0x3FBF) XRADIOSTAT1 ;
__xdata volatile unsigned short __at(0x3FBE) XRADIOSTAT ;
__xdata volatile unsigned char __at(0x3FDF) XSPCLKSRC ;
__xdata volatile unsigned char __at(0x3FDC) XSPMODE ;
__xdata volatile unsigned char __at(0x3FDE) XSPSHREG ;
__xdata volatile unsigned char __at(0x3FDD) XSPSTATUS ;
__xdata volatile unsigned char __at(0x3F9A) XT0CLKSRC ;
__xdata volatile unsigned char __at(0x3F9C) XT0CNT0 ;
__xdata volatile unsigned char __at(0x3F9D) XT0CNT1 ;
__xdata volatile unsigned short __at(0x3F9C) XT0CNT ;
__xdata volatile unsigned char __at(0x3F99) XT0MODE ;
__xdata volatile unsigned char __at(0x3F9E) XT0PERIOD0 ;
__xdata volatile unsigned char __at(0x3F9F) XT0PERIOD1 ;
__xdata volatile unsigned short __at(0x3F9E) XT0PERIOD ;
__xdata volatile unsigned char __at(0x3F9B) XT0STATUS ;
__xdata volatile unsigned char __at(0x3FA2) XT1CLKSRC ;
__xdata volatile unsigned char __at(0x3FA4) XT1CNT0 ;
__xdata volatile unsigned char __at(0x3FA5) XT1CNT1 ;
__xdata volatile unsigned short __at(0x3FA4) XT1CNT ;
__xdata volatile unsigned char __at(0x3FA1) XT1MODE ;
__xdata volatile unsigned char __at(0x3FA6) XT1PERIOD0 ;
__xdata volatile unsigned char __at(0x3FA7) XT1PERIOD1 ;
__xdata volatile unsigned short __at(0x3FA6) XT1PERIOD ;
__xdata volatile unsigned char __at(0x3FA3) XT1STATUS ;
__xdata volatile unsigned char __at(0x3FAA) XT2CLKSRC ;
__xdata volatile unsigned char __at(0x3FAC) XT2CNT0 ;
__xdata volatile unsigned char __at(0x3FAD) XT2CNT1 ;
__xdata volatile unsigned short __at(0x3FAC) XT2CNT ;
__xdata volatile unsigned char __at(0x3FA9) XT2MODE ;
__xdata volatile unsigned char __at(0x3FAE) XT2PERIOD0 ;
__xdata volatile unsigned char __at(0x3FAF) XT2PERIOD1 ;
__xdata volatile unsigned short __at(0x3FAE) XT2PERIOD ;
__xdata volatile unsigned char __at(0x3FAB) XT2STATUS ;
__xdata volatile unsigned char __at(0x3FE4) XU0CTRL ;
__xdata volatile unsigned char __at(0x3FE7) XU0MODE ;
__xdata volatile unsigned char __at(0x3FE6) XU0SHREG ;
__xdata volatile unsigned char __at(0x3FE5) XU0STATUS ;
__xdata volatile unsigned char __at(0x3FEC) XU1CTRL ;
__xdata volatile unsigned char __at(0x3FEF) XU1MODE ;
__xdata volatile unsigned char __at(0x3FEE) XU1SHREG ;
__xdata volatile unsigned char __at(0x3FED) XU1STATUS ;
__xdata volatile unsigned char __at(0x3FDA) XWDTCFG ;
__xdata volatile unsigned char __at(0x3FDB) XWDTRESET ;
__xdata volatile unsigned char __at(0x3FF1) XWTCFGA ;
__xdata volatile unsigned char __at(0x3FF9) XWTCFGB ;
__xdata volatile unsigned char __at(0x3FF2) XWTCNTA0 ;
__xdata volatile unsigned char __at(0x3FF3) XWTCNTA1 ;
__xdata volatile unsigned short __at(0x3FF2) XWTCNTA ;
__xdata volatile unsigned char __at(0x3FFA) XWTCNTB0 ;
__xdata volatile unsigned char __at(0x3FFB) XWTCNTB1 ;
__xdata volatile unsigned short __at(0x3FFA) XWTCNTB ;
__xdata volatile unsigned char __at(0x3FEB) XWTCNTR1 ;
__xdata volatile unsigned char __at(0x3FF4) XWTEVTA0 ;
__xdata volatile unsigned char __at(0x3FF5) XWTEVTA1 ;
__xdata volatile unsigned short __at(0x3FF4) XWTEVTA ;
__xdata volatile unsigned char __at(0x3FF6) XWTEVTB0 ;
__xdata volatile unsigned char __at(0x3FF7) XWTEVTB1 ;
__xdata volatile unsigned short __at(0x3FF6) XWTEVTB ;
__xdata volatile unsigned char __at(0x3FFC) XWTEVTC0 ;
__xdata volatile unsigned char __at(0x3FFD) XWTEVTC1 ;
__xdata volatile unsigned short __at(0x3FFC) XWTEVTC ;
__xdata volatile unsigned char __at(0x3FFE) XWTEVTD0 ;
__xdata volatile unsigned char __at(0x3FFF) XWTEVTD1 ;
__xdata volatile unsigned short __at(0x3FFE) XWTEVTD ;
__xdata volatile unsigned char __at(0x3FE9) XWTIRQEN ;
__xdata volatile unsigned char __at(0x3FEA) XWTSTAT ;





__xdata volatile unsigned char __at(0x4114) AX5043_AFSKCTRL ;
__xdata volatile unsigned char __at(0x4113) AX5043_AFSKMARK0 ;
__xdata volatile unsigned char __at(0x4112) AX5043_AFSKMARK1 ;
__xdata volatile unsigned char __at(0x4111) AX5043_AFSKSPACE0 ;
__xdata volatile unsigned char __at(0x4110) AX5043_AFSKSPACE1 ;
__xdata volatile unsigned char __at(0x4043) AX5043_AGCCOUNTER ;
__xdata volatile unsigned char __at(0x4115) AX5043_AMPLFILTER ;
__xdata volatile unsigned char __at(0x4189) AX5043_BBOFFSCAP ;
__xdata volatile unsigned char __at(0x4188) AX5043_BBTUNE ;
__xdata volatile unsigned char __at(0x4041) AX5043_BGNDRSSI ;
__xdata volatile unsigned char __at(0x422E) AX5043_BGNDRSSIGAIN ;
__xdata volatile unsigned char __at(0x422F) AX5043_BGNDRSSITHR ;
__xdata volatile unsigned char __at(0x4017) AX5043_CRCINIT0 ;
__xdata volatile unsigned char __at(0x4016) AX5043_CRCINIT1 ;
__xdata volatile unsigned char __at(0x4015) AX5043_CRCINIT2 ;
__xdata volatile unsigned char __at(0x4014) AX5043_CRCINIT3 ;
__xdata volatile unsigned char __at(0x4332) AX5043_DACCONFIG ;
__xdata volatile unsigned char __at(0x4331) AX5043_DACVALUE0 ;
__xdata volatile unsigned char __at(0x4330) AX5043_DACVALUE1 ;
__xdata volatile unsigned char __at(0x4102) AX5043_DECIMATION ;
__xdata volatile unsigned char __at(0x4042) AX5043_DIVERSITY ;
__xdata volatile unsigned char __at(0x4011) AX5043_ENCODING ;
__xdata volatile unsigned char __at(0x4018) AX5043_FEC ;
__xdata volatile unsigned char __at(0x401A) AX5043_FECSTATUS ;
__xdata volatile unsigned char __at(0x4019) AX5043_FECSYNC ;
__xdata volatile unsigned char __at(0x402B) AX5043_FIFOCOUNT0 ;
__xdata volatile unsigned char __at(0x402A) AX5043_FIFOCOUNT1 ;
__xdata volatile unsigned char __at(0x4029) AX5043_FIFODATA ;
__xdata volatile unsigned char __at(0x402D) AX5043_FIFOFREE0 ;
__xdata volatile unsigned char __at(0x402C) AX5043_FIFOFREE1 ;
__xdata volatile unsigned char __at(0x4028) AX5043_FIFOSTAT ;
__xdata volatile unsigned char __at(0x402F) AX5043_FIFOTHRESH0 ;
__xdata volatile unsigned char __at(0x402E) AX5043_FIFOTHRESH1 ;
__xdata volatile unsigned char __at(0x4012) AX5043_FRAMING ;
__xdata volatile unsigned char __at(0x4037) AX5043_FREQA0 ;
__xdata volatile unsigned char __at(0x4036) AX5043_FREQA1 ;
__xdata volatile unsigned char __at(0x4035) AX5043_FREQA2 ;
__xdata volatile unsigned char __at(0x4034) AX5043_FREQA3 ;
__xdata volatile unsigned char __at(0x403F) AX5043_FREQB0 ;
__xdata volatile unsigned char __at(0x403E) AX5043_FREQB1 ;
__xdata volatile unsigned char __at(0x403D) AX5043_FREQB2 ;
__xdata volatile unsigned char __at(0x403C) AX5043_FREQB3 ;
__xdata volatile unsigned char __at(0x4163) AX5043_FSKDEV0 ;
__xdata volatile unsigned char __at(0x4162) AX5043_FSKDEV1 ;
__xdata volatile unsigned char __at(0x4161) AX5043_FSKDEV2 ;
__xdata volatile unsigned char __at(0x410D) AX5043_FSKDMAX0 ;
__xdata volatile unsigned char __at(0x410C) AX5043_FSKDMAX1 ;
__xdata volatile unsigned char __at(0x410F) AX5043_FSKDMIN0 ;
__xdata volatile unsigned char __at(0x410E) AX5043_FSKDMIN1 ;
__xdata volatile unsigned char __at(0x4309) AX5043_GPADC13VALUE0 ;
__xdata volatile unsigned char __at(0x4308) AX5043_GPADC13VALUE1 ;
__xdata volatile unsigned char __at(0x4300) AX5043_GPADCCTRL ;
__xdata volatile unsigned char __at(0x4301) AX5043_GPADCPERIOD ;
__xdata volatile unsigned char __at(0x4101) AX5043_IFFREQ0 ;
__xdata volatile unsigned char __at(0x4100) AX5043_IFFREQ1 ;
__xdata volatile unsigned char __at(0x400B) AX5043_IRQINVERSION0 ;
__xdata volatile unsigned char __at(0x400A) AX5043_IRQINVERSION1 ;
__xdata volatile unsigned char __at(0x4007) AX5043_IRQMASK0 ;
__xdata volatile unsigned char __at(0x4006) AX5043_IRQMASK1 ;
__xdata volatile unsigned char __at(0x400D) AX5043_IRQREQUEST0 ;
__xdata volatile unsigned char __at(0x400C) AX5043_IRQREQUEST1 ;
__xdata volatile unsigned char __at(0x4310) AX5043_LPOSCCONFIG ;
__xdata volatile unsigned char __at(0x4317) AX5043_LPOSCFREQ0 ;
__xdata volatile unsigned char __at(0x4316) AX5043_LPOSCFREQ1 ;
__xdata volatile unsigned char __at(0x4313) AX5043_LPOSCKFILT0 ;
__xdata volatile unsigned char __at(0x4312) AX5043_LPOSCKFILT1 ;
__xdata volatile unsigned char __at(0x4319) AX5043_LPOSCPER0 ;
__xdata volatile unsigned char __at(0x4318) AX5043_LPOSCPER1 ;
__xdata volatile unsigned char __at(0x4315) AX5043_LPOSCREF0 ;
__xdata volatile unsigned char __at(0x4314) AX5043_LPOSCREF1 ;
__xdata volatile unsigned char __at(0x4311) AX5043_LPOSCSTATUS ;
__xdata volatile unsigned char __at(0x4214) AX5043_MATCH0LEN ;
__xdata volatile unsigned char __at(0x4216) AX5043_MATCH0MAX ;
__xdata volatile unsigned char __at(0x4215) AX5043_MATCH0MIN ;
__xdata volatile unsigned char __at(0x4213) AX5043_MATCH0PAT0 ;
__xdata volatile unsigned char __at(0x4212) AX5043_MATCH0PAT1 ;
__xdata volatile unsigned char __at(0x4211) AX5043_MATCH0PAT2 ;
__xdata volatile unsigned char __at(0x4210) AX5043_MATCH0PAT3 ;
__xdata volatile unsigned char __at(0x421C) AX5043_MATCH1LEN ;
__xdata volatile unsigned char __at(0x421E) AX5043_MATCH1MAX ;
__xdata volatile unsigned char __at(0x421D) AX5043_MATCH1MIN ;
__xdata volatile unsigned char __at(0x4219) AX5043_MATCH1PAT0 ;
__xdata volatile unsigned char __at(0x4218) AX5043_MATCH1PAT1 ;
__xdata volatile unsigned char __at(0x4108) AX5043_MAXDROFFSET0 ;
__xdata volatile unsigned char __at(0x4107) AX5043_MAXDROFFSET1 ;
__xdata volatile unsigned char __at(0x4106) AX5043_MAXDROFFSET2 ;
__xdata volatile unsigned char __at(0x410B) AX5043_MAXRFOFFSET0 ;
__xdata volatile unsigned char __at(0x410A) AX5043_MAXRFOFFSET1 ;
__xdata volatile unsigned char __at(0x4109) AX5043_MAXRFOFFSET2 ;
__xdata volatile unsigned char __at(0x4164) AX5043_MODCFGA ;
__xdata volatile unsigned char __at(0x4160) AX5043_MODCFGF ;
__xdata volatile unsigned char __at(0x4010) AX5043_MODULATION ;
__xdata volatile unsigned char __at(0x4025) AX5043_PINFUNCANTSEL ;
__xdata volatile unsigned char __at(0x4023) AX5043_PINFUNCDATA ;
__xdata volatile unsigned char __at(0x4022) AX5043_PINFUNCDCLK ;
__xdata volatile unsigned char __at(0x4024) AX5043_PINFUNCIRQ ;
__xdata volatile unsigned char __at(0x4026) AX5043_PINFUNCPWRAMP ;
__xdata volatile unsigned char __at(0x4021) AX5043_PINFUNCSYSCLK ;
__xdata volatile unsigned char __at(0x4020) AX5043_PINSTATE ;
__xdata volatile unsigned char __at(0x4233) AX5043_PKTACCEPTFLAGS ;
__xdata volatile unsigned char __at(0x4230) AX5043_PKTCHUNKSIZE ;
__xdata volatile unsigned char __at(0x4231) AX5043_PKTMISCFLAGS ;
__xdata volatile unsigned char __at(0x4232) AX5043_PKTSTOREFLAGS ;
__xdata volatile unsigned char __at(0x4031) AX5043_PLLCPI ;
__xdata volatile unsigned char __at(0x4039) AX5043_PLLCPIBOOST ;
__xdata volatile unsigned char __at(0x4182) AX5043_PLLLOCKDET ;
__xdata volatile unsigned char __at(0x4030) AX5043_PLLLOOP ;
__xdata volatile unsigned char __at(0x4038) AX5043_PLLLOOPBOOST ;
__xdata volatile unsigned char __at(0x4033) AX5043_PLLRANGINGA ;
__xdata volatile unsigned char __at(0x403B) AX5043_PLLRANGINGB ;
__xdata volatile unsigned char __at(0x4183) AX5043_PLLRNGCLK ;
__xdata volatile unsigned char __at(0x4032) AX5043_PLLVCODIV ;
__xdata volatile unsigned char __at(0x4180) AX5043_PLLVCOI ;
__xdata volatile unsigned char __at(0x4181) AX5043_PLLVCOIR ;
__xdata volatile unsigned char __at(0x4005) AX5043_POWIRQMASK ;
__xdata volatile unsigned char __at(0x4003) AX5043_POWSTAT ;
__xdata volatile unsigned char __at(0x4004) AX5043_POWSTICKYSTAT ;
__xdata volatile unsigned char __at(0x4027) AX5043_PWRAMP ;
__xdata volatile unsigned char __at(0x4002) AX5043_PWRMODE ;
__xdata volatile unsigned char __at(0x4009) AX5043_RADIOEVENTMASK0 ;
__xdata volatile unsigned char __at(0x4008) AX5043_RADIOEVENTMASK1 ;
__xdata volatile unsigned char __at(0x400F) AX5043_RADIOEVENTREQ0 ;
__xdata volatile unsigned char __at(0x400E) AX5043_RADIOEVENTREQ1 ;
__xdata volatile unsigned char __at(0x401C) AX5043_RADIOSTATE ;
__xdata volatile unsigned char __at(0x4040) AX5043_RSSI ;
__xdata volatile unsigned char __at(0x422D) AX5043_RSSIABSTHR ;
__xdata volatile unsigned char __at(0x422C) AX5043_RSSIREFERENCE ;
__xdata volatile unsigned char __at(0x4105) AX5043_RXDATARATE0 ;
__xdata volatile unsigned char __at(0x4104) AX5043_RXDATARATE1 ;
__xdata volatile unsigned char __at(0x4103) AX5043_RXDATARATE2 ;
__xdata volatile unsigned char __at(0x4001) AX5043_SCRATCH ;
__xdata volatile unsigned char __at(0x4000) AX5043_SILICONREVISION ;
__xdata volatile unsigned char __at(0x405B) AX5043_TIMER0 ;
__xdata volatile unsigned char __at(0x405A) AX5043_TIMER1 ;
__xdata volatile unsigned char __at(0x4059) AX5043_TIMER2 ;
__xdata volatile unsigned char __at(0x4227) AX5043_TMGRXAGC ;
__xdata volatile unsigned char __at(0x4223) AX5043_TMGRXBOOST ;
__xdata volatile unsigned char __at(0x4226) AX5043_TMGRXCOARSEAGC ;
__xdata volatile unsigned char __at(0x4225) AX5043_TMGRXOFFSACQ ;
__xdata volatile unsigned char __at(0x4229) AX5043_TMGRXPREAMBLE1 ;
__xdata volatile unsigned char __at(0x422A) AX5043_TMGRXPREAMBLE2 ;
__xdata volatile unsigned char __at(0x422B) AX5043_TMGRXPREAMBLE3 ;
__xdata volatile unsigned char __at(0x4228) AX5043_TMGRXRSSI ;
__xdata volatile unsigned char __at(0x4224) AX5043_TMGRXSETTLE ;
__xdata volatile unsigned char __at(0x4220) AX5043_TMGTXBOOST ;
__xdata volatile unsigned char __at(0x4221) AX5043_TMGTXSETTLE ;
__xdata volatile unsigned char __at(0x4055) AX5043_TRKAFSKDEMOD0 ;
__xdata volatile unsigned char __at(0x4054) AX5043_TRKAFSKDEMOD1 ;
__xdata volatile unsigned char __at(0x4049) AX5043_TRKAMPLITUDE0 ;
__xdata volatile unsigned char __at(0x4048) AX5043_TRKAMPLITUDE1 ;
__xdata volatile unsigned char __at(0x4047) AX5043_TRKDATARATE0 ;
__xdata volatile unsigned char __at(0x4046) AX5043_TRKDATARATE1 ;
__xdata volatile unsigned char __at(0x4045) AX5043_TRKDATARATE2 ;
__xdata volatile unsigned char __at(0x4051) AX5043_TRKFREQ0 ;
__xdata volatile unsigned char __at(0x4050) AX5043_TRKFREQ1 ;
__xdata volatile unsigned char __at(0x4053) AX5043_TRKFSKDEMOD0 ;
__xdata volatile unsigned char __at(0x4052) AX5043_TRKFSKDEMOD1 ;
__xdata volatile unsigned char __at(0x404B) AX5043_TRKPHASE0 ;
__xdata volatile unsigned char __at(0x404A) AX5043_TRKPHASE1 ;
__xdata volatile unsigned char __at(0x404F) AX5043_TRKRFFREQ0 ;
__xdata volatile unsigned char __at(0x404E) AX5043_TRKRFFREQ1 ;
__xdata volatile unsigned char __at(0x404D) AX5043_TRKRFFREQ2 ;
__xdata volatile unsigned char __at(0x4169) AX5043_TXPWRCOEFFA0 ;
__xdata volatile unsigned char __at(0x4168) AX5043_TXPWRCOEFFA1 ;
__xdata volatile unsigned char __at(0x416B) AX5043_TXPWRCOEFFB0 ;
__xdata volatile unsigned char __at(0x416A) AX5043_TXPWRCOEFFB1 ;
__xdata volatile unsigned char __at(0x416D) AX5043_TXPWRCOEFFC0 ;
__xdata volatile unsigned char __at(0x416C) AX5043_TXPWRCOEFFC1 ;
__xdata volatile unsigned char __at(0x416F) AX5043_TXPWRCOEFFD0 ;
__xdata volatile unsigned char __at(0x416E) AX5043_TXPWRCOEFFD1 ;
__xdata volatile unsigned char __at(0x4171) AX5043_TXPWRCOEFFE0 ;
__xdata volatile unsigned char __at(0x4170) AX5043_TXPWRCOEFFE1 ;
__xdata volatile unsigned char __at(0x4167) AX5043_TXRATE0 ;
__xdata volatile unsigned char __at(0x4166) AX5043_TXRATE1 ;
__xdata volatile unsigned char __at(0x4165) AX5043_TXRATE2 ;
__xdata volatile unsigned char __at(0x406B) AX5043_WAKEUP0 ;
__xdata volatile unsigned char __at(0x406A) AX5043_WAKEUP1 ;
__xdata volatile unsigned char __at(0x406D) AX5043_WAKEUPFREQ0 ;
__xdata volatile unsigned char __at(0x406C) AX5043_WAKEUPFREQ1 ;
__xdata volatile unsigned char __at(0x4069) AX5043_WAKEUPTIMER0 ;
__xdata volatile unsigned char __at(0x4068) AX5043_WAKEUPTIMER1 ;
__xdata volatile unsigned char __at(0x406E) AX5043_WAKEUPXOEARLY ;
__xdata volatile unsigned char __at(0x4184) AX5043_XTALCAP ;
__xdata volatile unsigned char __at(0x401D) AX5043_XTALSTATUS ;
# 799 "C://Program Files (x86)//AXSEM//AXSDB//libmf//include/ax8052f143.h"
__xdata volatile unsigned char __at(0x4122) AX5043_AGCAHYST0 ;
__xdata volatile unsigned char __at(0x4132) AX5043_AGCAHYST1 ;
__xdata volatile unsigned char __at(0x4142) AX5043_AGCAHYST2 ;
__xdata volatile unsigned char __at(0x4152) AX5043_AGCAHYST3 ;
__xdata volatile unsigned char __at(0x4120) AX5043_AGCGAIN0 ;
__xdata volatile unsigned char __at(0x4130) AX5043_AGCGAIN1 ;
__xdata volatile unsigned char __at(0x4140) AX5043_AGCGAIN2 ;
__xdata volatile unsigned char __at(0x4150) AX5043_AGCGAIN3 ;
__xdata volatile unsigned char __at(0x4123) AX5043_AGCMINMAX0 ;
__xdata volatile unsigned char __at(0x4133) AX5043_AGCMINMAX1 ;
__xdata volatile unsigned char __at(0x4143) AX5043_AGCMINMAX2 ;
__xdata volatile unsigned char __at(0x4153) AX5043_AGCMINMAX3 ;
__xdata volatile unsigned char __at(0x4121) AX5043_AGCTARGET0 ;
__xdata volatile unsigned char __at(0x4131) AX5043_AGCTARGET1 ;
__xdata volatile unsigned char __at(0x4141) AX5043_AGCTARGET2 ;
__xdata volatile unsigned char __at(0x4151) AX5043_AGCTARGET3 ;
__xdata volatile unsigned char __at(0x412B) AX5043_AMPLITUDEGAIN0 ;
__xdata volatile unsigned char __at(0x413B) AX5043_AMPLITUDEGAIN1 ;
__xdata volatile unsigned char __at(0x414B) AX5043_AMPLITUDEGAIN2 ;
__xdata volatile unsigned char __at(0x415B) AX5043_AMPLITUDEGAIN3 ;
__xdata volatile unsigned char __at(0x412F) AX5043_BBOFFSRES0 ;
__xdata volatile unsigned char __at(0x413F) AX5043_BBOFFSRES1 ;
__xdata volatile unsigned char __at(0x414F) AX5043_BBOFFSRES2 ;
__xdata volatile unsigned char __at(0x415F) AX5043_BBOFFSRES3 ;
__xdata volatile unsigned char __at(0x4125) AX5043_DRGAIN0 ;
__xdata volatile unsigned char __at(0x4135) AX5043_DRGAIN1 ;
__xdata volatile unsigned char __at(0x4145) AX5043_DRGAIN2 ;
__xdata volatile unsigned char __at(0x4155) AX5043_DRGAIN3 ;
__xdata volatile unsigned char __at(0x412E) AX5043_FOURFSK0 ;
__xdata volatile unsigned char __at(0x413E) AX5043_FOURFSK1 ;
__xdata volatile unsigned char __at(0x414E) AX5043_FOURFSK2 ;
__xdata volatile unsigned char __at(0x415E) AX5043_FOURFSK3 ;
__xdata volatile unsigned char __at(0x412D) AX5043_FREQDEV00 ;
__xdata volatile unsigned char __at(0x413D) AX5043_FREQDEV01 ;
__xdata volatile unsigned char __at(0x414D) AX5043_FREQDEV02 ;
__xdata volatile unsigned char __at(0x415D) AX5043_FREQDEV03 ;
__xdata volatile unsigned char __at(0x412C) AX5043_FREQDEV10 ;
__xdata volatile unsigned char __at(0x413C) AX5043_FREQDEV11 ;
__xdata volatile unsigned char __at(0x414C) AX5043_FREQDEV12 ;
__xdata volatile unsigned char __at(0x415C) AX5043_FREQDEV13 ;
__xdata volatile unsigned char __at(0x4127) AX5043_FREQUENCYGAINA0 ;
__xdata volatile unsigned char __at(0x4137) AX5043_FREQUENCYGAINA1 ;
__xdata volatile unsigned char __at(0x4147) AX5043_FREQUENCYGAINA2 ;
__xdata volatile unsigned char __at(0x4157) AX5043_FREQUENCYGAINA3 ;
__xdata volatile unsigned char __at(0x4128) AX5043_FREQUENCYGAINB0 ;
__xdata volatile unsigned char __at(0x4138) AX5043_FREQUENCYGAINB1 ;
__xdata volatile unsigned char __at(0x4148) AX5043_FREQUENCYGAINB2 ;
__xdata volatile unsigned char __at(0x4158) AX5043_FREQUENCYGAINB3 ;
__xdata volatile unsigned char __at(0x4129) AX5043_FREQUENCYGAINC0 ;
__xdata volatile unsigned char __at(0x4139) AX5043_FREQUENCYGAINC1 ;
__xdata volatile unsigned char __at(0x4149) AX5043_FREQUENCYGAINC2 ;
__xdata volatile unsigned char __at(0x4159) AX5043_FREQUENCYGAINC3 ;
__xdata volatile unsigned char __at(0x412A) AX5043_FREQUENCYGAIND0 ;
__xdata volatile unsigned char __at(0x413A) AX5043_FREQUENCYGAIND1 ;
__xdata volatile unsigned char __at(0x414A) AX5043_FREQUENCYGAIND2 ;
__xdata volatile unsigned char __at(0x415A) AX5043_FREQUENCYGAIND3 ;
__xdata volatile unsigned char __at(0x4116) AX5043_FREQUENCYLEAK ;
__xdata volatile unsigned char __at(0x4126) AX5043_PHASEGAIN0 ;
__xdata volatile unsigned char __at(0x4136) AX5043_PHASEGAIN1 ;
__xdata volatile unsigned char __at(0x4146) AX5043_PHASEGAIN2 ;
__xdata volatile unsigned char __at(0x4156) AX5043_PHASEGAIN3 ;
__xdata volatile unsigned char __at(0x4207) AX5043_PKTADDR0 ;
__xdata volatile unsigned char __at(0x4206) AX5043_PKTADDR1 ;
__xdata volatile unsigned char __at(0x4205) AX5043_PKTADDR2 ;
__xdata volatile unsigned char __at(0x4204) AX5043_PKTADDR3 ;
__xdata volatile unsigned char __at(0x4200) AX5043_PKTADDRCFG ;
__xdata volatile unsigned char __at(0x420B) AX5043_PKTADDRMASK0 ;
__xdata volatile unsigned char __at(0x420A) AX5043_PKTADDRMASK1 ;
__xdata volatile unsigned char __at(0x4209) AX5043_PKTADDRMASK2 ;
__xdata volatile unsigned char __at(0x4208) AX5043_PKTADDRMASK3 ;
__xdata volatile unsigned char __at(0x4201) AX5043_PKTLENCFG ;
__xdata volatile unsigned char __at(0x4202) AX5043_PKTLENOFFSET ;
__xdata volatile unsigned char __at(0x4203) AX5043_PKTMAXLEN ;
__xdata volatile unsigned char __at(0x4118) AX5043_RXPARAMCURSET ;
__xdata volatile unsigned char __at(0x4117) AX5043_RXPARAMSETS ;
__xdata volatile unsigned char __at(0x4124) AX5043_TIMEGAIN0 ;
__xdata volatile unsigned char __at(0x4134) AX5043_TIMEGAIN1 ;
__xdata volatile unsigned char __at(0x4144) AX5043_TIMEGAIN2 ;
__xdata volatile unsigned char __at(0x4154) AX5043_TIMEGAIN3 ;





__xdata volatile unsigned char __at(0x5114) AX5043_AFSKCTRLNB ;
__xdata volatile unsigned char __at(0x5113) AX5043_AFSKMARK0NB ;
__xdata volatile unsigned char __at(0x5112) AX5043_AFSKMARK1NB ;
__xdata volatile unsigned char __at(0x5111) AX5043_AFSKSPACE0NB ;
__xdata volatile unsigned char __at(0x5110) AX5043_AFSKSPACE1NB ;
__xdata volatile unsigned char __at(0x5043) AX5043_AGCCOUNTERNB ;
__xdata volatile unsigned char __at(0x5115) AX5043_AMPLFILTERNB ;
__xdata volatile unsigned char __at(0x5189) AX5043_BBOFFSCAPNB ;
__xdata volatile unsigned char __at(0x5188) AX5043_BBTUNENB ;
__xdata volatile unsigned char __at(0x5041) AX5043_BGNDRSSINB ;
__xdata volatile unsigned char __at(0x522E) AX5043_BGNDRSSIGAINNB ;
__xdata volatile unsigned char __at(0x522F) AX5043_BGNDRSSITHRNB ;
__xdata volatile unsigned char __at(0x5017) AX5043_CRCINIT0NB ;
__xdata volatile unsigned char __at(0x5016) AX5043_CRCINIT1NB ;
__xdata volatile unsigned char __at(0x5015) AX5043_CRCINIT2NB ;
__xdata volatile unsigned char __at(0x5014) AX5043_CRCINIT3NB ;
__xdata volatile unsigned char __at(0x5332) AX5043_DACCONFIGNB ;
__xdata volatile unsigned char __at(0x5331) AX5043_DACVALUE0NB ;
__xdata volatile unsigned char __at(0x5330) AX5043_DACVALUE1NB ;
__xdata volatile unsigned char __at(0x5102) AX5043_DECIMATIONNB ;
__xdata volatile unsigned char __at(0x5042) AX5043_DIVERSITYNB ;
__xdata volatile unsigned char __at(0x5011) AX5043_ENCODINGNB ;
__xdata volatile unsigned char __at(0x5018) AX5043_FECNB ;
__xdata volatile unsigned char __at(0x501A) AX5043_FECSTATUSNB ;
__xdata volatile unsigned char __at(0x5019) AX5043_FECSYNCNB ;
__xdata volatile unsigned char __at(0x502B) AX5043_FIFOCOUNT0NB ;
__xdata volatile unsigned char __at(0x502A) AX5043_FIFOCOUNT1NB ;
__xdata volatile unsigned char __at(0x5029) AX5043_FIFODATANB ;
__xdata volatile unsigned char __at(0x502D) AX5043_FIFOFREE0NB ;
__xdata volatile unsigned char __at(0x502C) AX5043_FIFOFREE1NB ;
__xdata volatile unsigned char __at(0x5028) AX5043_FIFOSTATNB ;
__xdata volatile unsigned char __at(0x502F) AX5043_FIFOTHRESH0NB ;
__xdata volatile unsigned char __at(0x502E) AX5043_FIFOTHRESH1NB ;
__xdata volatile unsigned char __at(0x5012) AX5043_FRAMINGNB ;
__xdata volatile unsigned char __at(0x5037) AX5043_FREQA0NB ;
__xdata volatile unsigned char __at(0x5036) AX5043_FREQA1NB ;
__xdata volatile unsigned char __at(0x5035) AX5043_FREQA2NB ;
__xdata volatile unsigned char __at(0x5034) AX5043_FREQA3NB ;
__xdata volatile unsigned char __at(0x503F) AX5043_FREQB0NB ;
__xdata volatile unsigned char __at(0x503E) AX5043_FREQB1NB ;
__xdata volatile unsigned char __at(0x503D) AX5043_FREQB2NB ;
__xdata volatile unsigned char __at(0x503C) AX5043_FREQB3NB ;
__xdata volatile unsigned char __at(0x5163) AX5043_FSKDEV0NB ;
__xdata volatile unsigned char __at(0x5162) AX5043_FSKDEV1NB ;
__xdata volatile unsigned char __at(0x5161) AX5043_FSKDEV2NB ;
__xdata volatile unsigned char __at(0x510D) AX5043_FSKDMAX0NB ;
__xdata volatile unsigned char __at(0x510C) AX5043_FSKDMAX1NB ;
__xdata volatile unsigned char __at(0x510F) AX5043_FSKDMIN0NB ;
__xdata volatile unsigned char __at(0x510E) AX5043_FSKDMIN1NB ;
__xdata volatile unsigned char __at(0x5309) AX5043_GPADC13VALUE0NB ;
__xdata volatile unsigned char __at(0x5308) AX5043_GPADC13VALUE1NB ;
__xdata volatile unsigned char __at(0x5300) AX5043_GPADCCTRLNB ;
__xdata volatile unsigned char __at(0x5301) AX5043_GPADCPERIODNB ;
__xdata volatile unsigned char __at(0x5101) AX5043_IFFREQ0NB ;
__xdata volatile unsigned char __at(0x5100) AX5043_IFFREQ1NB ;
__xdata volatile unsigned char __at(0x500B) AX5043_IRQINVERSION0NB ;
__xdata volatile unsigned char __at(0x500A) AX5043_IRQINVERSION1NB ;
__xdata volatile unsigned char __at(0x5007) AX5043_IRQMASK0NB ;
__xdata volatile unsigned char __at(0x5006) AX5043_IRQMASK1NB ;
__xdata volatile unsigned char __at(0x500D) AX5043_IRQREQUEST0NB ;
__xdata volatile unsigned char __at(0x500C) AX5043_IRQREQUEST1NB ;
__xdata volatile unsigned char __at(0x5310) AX5043_LPOSCCONFIGNB ;
__xdata volatile unsigned char __at(0x5317) AX5043_LPOSCFREQ0NB ;
__xdata volatile unsigned char __at(0x5316) AX5043_LPOSCFREQ1NB ;
__xdata volatile unsigned char __at(0x5313) AX5043_LPOSCKFILT0NB ;
__xdata volatile unsigned char __at(0x5312) AX5043_LPOSCKFILT1NB ;
__xdata volatile unsigned char __at(0x5319) AX5043_LPOSCPER0NB ;
__xdata volatile unsigned char __at(0x5318) AX5043_LPOSCPER1NB ;
__xdata volatile unsigned char __at(0x5315) AX5043_LPOSCREF0NB ;
__xdata volatile unsigned char __at(0x5314) AX5043_LPOSCREF1NB ;
__xdata volatile unsigned char __at(0x5311) AX5043_LPOSCSTATUSNB ;
__xdata volatile unsigned char __at(0x5214) AX5043_MATCH0LENNB ;
__xdata volatile unsigned char __at(0x5216) AX5043_MATCH0MAXNB ;
__xdata volatile unsigned char __at(0x5215) AX5043_MATCH0MINNB ;
__xdata volatile unsigned char __at(0x5213) AX5043_MATCH0PAT0NB ;
__xdata volatile unsigned char __at(0x5212) AX5043_MATCH0PAT1NB ;
__xdata volatile unsigned char __at(0x5211) AX5043_MATCH0PAT2NB ;
__xdata volatile unsigned char __at(0x5210) AX5043_MATCH0PAT3NB ;
__xdata volatile unsigned char __at(0x521C) AX5043_MATCH1LENNB ;
__xdata volatile unsigned char __at(0x521E) AX5043_MATCH1MAXNB ;
__xdata volatile unsigned char __at(0x521D) AX5043_MATCH1MINNB ;
__xdata volatile unsigned char __at(0x5219) AX5043_MATCH1PAT0NB ;
__xdata volatile unsigned char __at(0x5218) AX5043_MATCH1PAT1NB ;
__xdata volatile unsigned char __at(0x5108) AX5043_MAXDROFFSET0NB ;
__xdata volatile unsigned char __at(0x5107) AX5043_MAXDROFFSET1NB ;
__xdata volatile unsigned char __at(0x5106) AX5043_MAXDROFFSET2NB ;
__xdata volatile unsigned char __at(0x510B) AX5043_MAXRFOFFSET0NB ;
__xdata volatile unsigned char __at(0x510A) AX5043_MAXRFOFFSET1NB ;
__xdata volatile unsigned char __at(0x5109) AX5043_MAXRFOFFSET2NB ;
__xdata volatile unsigned char __at(0x5164) AX5043_MODCFGANB ;
__xdata volatile unsigned char __at(0x5160) AX5043_MODCFGFNB ;
__xdata volatile unsigned char __at(0x5010) AX5043_MODULATIONNB ;
__xdata volatile unsigned char __at(0x5025) AX5043_PINFUNCANTSELNB ;
__xdata volatile unsigned char __at(0x5023) AX5043_PINFUNCDATANB ;
__xdata volatile unsigned char __at(0x5022) AX5043_PINFUNCDCLKNB ;
__xdata volatile unsigned char __at(0x5024) AX5043_PINFUNCIRQNB ;
__xdata volatile unsigned char __at(0x5026) AX5043_PINFUNCPWRAMPNB ;
__xdata volatile unsigned char __at(0x5021) AX5043_PINFUNCSYSCLKNB ;
__xdata volatile unsigned char __at(0x5020) AX5043_PINSTATENB ;
__xdata volatile unsigned char __at(0x5233) AX5043_PKTACCEPTFLAGSNB ;
__xdata volatile unsigned char __at(0x5230) AX5043_PKTCHUNKSIZENB ;
__xdata volatile unsigned char __at(0x5231) AX5043_PKTMISCFLAGSNB ;
__xdata volatile unsigned char __at(0x5232) AX5043_PKTSTOREFLAGSNB ;
__xdata volatile unsigned char __at(0x5031) AX5043_PLLCPINB ;
__xdata volatile unsigned char __at(0x5039) AX5043_PLLCPIBOOSTNB ;
__xdata volatile unsigned char __at(0x5182) AX5043_PLLLOCKDETNB ;
__xdata volatile unsigned char __at(0x5030) AX5043_PLLLOOPNB ;
__xdata volatile unsigned char __at(0x5038) AX5043_PLLLOOPBOOSTNB ;
__xdata volatile unsigned char __at(0x5033) AX5043_PLLRANGINGANB ;
__xdata volatile unsigned char __at(0x503B) AX5043_PLLRANGINGBNB ;
__xdata volatile unsigned char __at(0x5183) AX5043_PLLRNGCLKNB ;
__xdata volatile unsigned char __at(0x5032) AX5043_PLLVCODIVNB ;
__xdata volatile unsigned char __at(0x5180) AX5043_PLLVCOINB ;
__xdata volatile unsigned char __at(0x5181) AX5043_PLLVCOIRNB ;
__xdata volatile unsigned char __at(0x5005) AX5043_POWIRQMASKNB ;
__xdata volatile unsigned char __at(0x5003) AX5043_POWSTATNB ;
__xdata volatile unsigned char __at(0x5004) AX5043_POWSTICKYSTATNB ;
__xdata volatile unsigned char __at(0x5027) AX5043_PWRAMPNB ;
__xdata volatile unsigned char __at(0x5002) AX5043_PWRMODENB ;
__xdata volatile unsigned char __at(0x5009) AX5043_RADIOEVENTMASK0NB ;
__xdata volatile unsigned char __at(0x5008) AX5043_RADIOEVENTMASK1NB ;
__xdata volatile unsigned char __at(0x500F) AX5043_RADIOEVENTREQ0NB ;
__xdata volatile unsigned char __at(0x500E) AX5043_RADIOEVENTREQ1NB ;
__xdata volatile unsigned char __at(0x501C) AX5043_RADIOSTATENB ;
__xdata volatile unsigned char __at(0x5040) AX5043_RSSINB ;
__xdata volatile unsigned char __at(0x522D) AX5043_RSSIABSTHRNB ;
__xdata volatile unsigned char __at(0x522C) AX5043_RSSIREFERENCENB ;
__xdata volatile unsigned char __at(0x5105) AX5043_RXDATARATE0NB ;
__xdata volatile unsigned char __at(0x5104) AX5043_RXDATARATE1NB ;
__xdata volatile unsigned char __at(0x5103) AX5043_RXDATARATE2NB ;
__xdata volatile unsigned char __at(0x5001) AX5043_SCRATCHNB ;
__xdata volatile unsigned char __at(0x5000) AX5043_SILICONREVISIONNB ;
__xdata volatile unsigned char __at(0x505B) AX5043_TIMER0NB ;
__xdata volatile unsigned char __at(0x505A) AX5043_TIMER1NB ;
__xdata volatile unsigned char __at(0x5059) AX5043_TIMER2NB ;
__xdata volatile unsigned char __at(0x5227) AX5043_TMGRXAGCNB ;
__xdata volatile unsigned char __at(0x5223) AX5043_TMGRXBOOSTNB ;
__xdata volatile unsigned char __at(0x5226) AX5043_TMGRXCOARSEAGCNB ;
__xdata volatile unsigned char __at(0x5225) AX5043_TMGRXOFFSACQNB ;
__xdata volatile unsigned char __at(0x5229) AX5043_TMGRXPREAMBLE1NB ;
__xdata volatile unsigned char __at(0x522A) AX5043_TMGRXPREAMBLE2NB ;
__xdata volatile unsigned char __at(0x522B) AX5043_TMGRXPREAMBLE3NB ;
__xdata volatile unsigned char __at(0x5228) AX5043_TMGRXRSSINB ;
__xdata volatile unsigned char __at(0x5224) AX5043_TMGRXSETTLENB ;
__xdata volatile unsigned char __at(0x5220) AX5043_TMGTXBOOSTNB ;
__xdata volatile unsigned char __at(0x5221) AX5043_TMGTXSETTLENB ;
__xdata volatile unsigned char __at(0x5055) AX5043_TRKAFSKDEMOD0NB ;
__xdata volatile unsigned char __at(0x5054) AX5043_TRKAFSKDEMOD1NB ;
__xdata volatile unsigned char __at(0x5049) AX5043_TRKAMPLITUDE0NB ;
__xdata volatile unsigned char __at(0x5048) AX5043_TRKAMPLITUDE1NB ;
__xdata volatile unsigned char __at(0x5047) AX5043_TRKDATARATE0NB ;
__xdata volatile unsigned char __at(0x5046) AX5043_TRKDATARATE1NB ;
__xdata volatile unsigned char __at(0x5045) AX5043_TRKDATARATE2NB ;
__xdata volatile unsigned char __at(0x5051) AX5043_TRKFREQ0NB ;
__xdata volatile unsigned char __at(0x5050) AX5043_TRKFREQ1NB ;
__xdata volatile unsigned char __at(0x5053) AX5043_TRKFSKDEMOD0NB ;
__xdata volatile unsigned char __at(0x5052) AX5043_TRKFSKDEMOD1NB ;
__xdata volatile unsigned char __at(0x504B) AX5043_TRKPHASE0NB ;
__xdata volatile unsigned char __at(0x504A) AX5043_TRKPHASE1NB ;
__xdata volatile unsigned char __at(0x504F) AX5043_TRKRFFREQ0NB ;
__xdata volatile unsigned char __at(0x504E) AX5043_TRKRFFREQ1NB ;
__xdata volatile unsigned char __at(0x504D) AX5043_TRKRFFREQ2NB ;
__xdata volatile unsigned char __at(0x5169) AX5043_TXPWRCOEFFA0NB ;
__xdata volatile unsigned char __at(0x5168) AX5043_TXPWRCOEFFA1NB ;
__xdata volatile unsigned char __at(0x516B) AX5043_TXPWRCOEFFB0NB ;
__xdata volatile unsigned char __at(0x516A) AX5043_TXPWRCOEFFB1NB ;
__xdata volatile unsigned char __at(0x516D) AX5043_TXPWRCOEFFC0NB ;
__xdata volatile unsigned char __at(0x516C) AX5043_TXPWRCOEFFC1NB ;
__xdata volatile unsigned char __at(0x516F) AX5043_TXPWRCOEFFD0NB ;
__xdata volatile unsigned char __at(0x516E) AX5043_TXPWRCOEFFD1NB ;
__xdata volatile unsigned char __at(0x5171) AX5043_TXPWRCOEFFE0NB ;
__xdata volatile unsigned char __at(0x5170) AX5043_TXPWRCOEFFE1NB ;
__xdata volatile unsigned char __at(0x5167) AX5043_TXRATE0NB ;
__xdata volatile unsigned char __at(0x5166) AX5043_TXRATE1NB ;
__xdata volatile unsigned char __at(0x5165) AX5043_TXRATE2NB ;
__xdata volatile unsigned char __at(0x506B) AX5043_WAKEUP0NB ;
__xdata volatile unsigned char __at(0x506A) AX5043_WAKEUP1NB ;
__xdata volatile unsigned char __at(0x506D) AX5043_WAKEUPFREQ0NB ;
__xdata volatile unsigned char __at(0x506C) AX5043_WAKEUPFREQ1NB ;
__xdata volatile unsigned char __at(0x5069) AX5043_WAKEUPTIMER0NB ;
__xdata volatile unsigned char __at(0x5068) AX5043_WAKEUPTIMER1NB ;
__xdata volatile unsigned char __at(0x506E) AX5043_WAKEUPXOEARLYNB ;
__xdata volatile unsigned char __at(0x5184) AX5043_XTALCAPNB ;
__xdata volatile unsigned char __at(0x501D) AX5043_XTALSTATUSNB ;
# 1136 "C://Program Files (x86)//AXSEM//AXSDB//libmf//include/ax8052f143.h"
__xdata volatile unsigned char __at(0x5122) AX5043_AGCAHYST0NB ;
__xdata volatile unsigned char __at(0x5132) AX5043_AGCAHYST1NB ;
__xdata volatile unsigned char __at(0x5142) AX5043_AGCAHYST2NB ;
__xdata volatile unsigned char __at(0x5152) AX5043_AGCAHYST3NB ;
__xdata volatile unsigned char __at(0x5120) AX5043_AGCGAIN0NB ;
__xdata volatile unsigned char __at(0x5130) AX5043_AGCGAIN1NB ;
__xdata volatile unsigned char __at(0x5140) AX5043_AGCGAIN2NB ;
__xdata volatile unsigned char __at(0x5150) AX5043_AGCGAIN3NB ;
__xdata volatile unsigned char __at(0x5123) AX5043_AGCMINMAX0NB ;
__xdata volatile unsigned char __at(0x5133) AX5043_AGCMINMAX1NB ;
__xdata volatile unsigned char __at(0x5143) AX5043_AGCMINMAX2NB ;
__xdata volatile unsigned char __at(0x5153) AX5043_AGCMINMAX3NB ;
__xdata volatile unsigned char __at(0x5121) AX5043_AGCTARGET0NB ;
__xdata volatile unsigned char __at(0x5131) AX5043_AGCTARGET1NB ;
__xdata volatile unsigned char __at(0x5141) AX5043_AGCTARGET2NB ;
__xdata volatile unsigned char __at(0x5151) AX5043_AGCTARGET3NB ;
__xdata volatile unsigned char __at(0x512B) AX5043_AMPLITUDEGAIN0NB ;
__xdata volatile unsigned char __at(0x513B) AX5043_AMPLITUDEGAIN1NB ;
__xdata volatile unsigned char __at(0x514B) AX5043_AMPLITUDEGAIN2NB ;
__xdata volatile unsigned char __at(0x515B) AX5043_AMPLITUDEGAIN3NB ;
__xdata volatile unsigned char __at(0x512F) AX5043_BBOFFSRES0NB ;
__xdata volatile unsigned char __at(0x513F) AX5043_BBOFFSRES1NB ;
__xdata volatile unsigned char __at(0x514F) AX5043_BBOFFSRES2NB ;
__xdata volatile unsigned char __at(0x515F) AX5043_BBOFFSRES3NB ;
__xdata volatile unsigned char __at(0x5125) AX5043_DRGAIN0NB ;
__xdata volatile unsigned char __at(0x5135) AX5043_DRGAIN1NB ;
__xdata volatile unsigned char __at(0x5145) AX5043_DRGAIN2NB ;
__xdata volatile unsigned char __at(0x5155) AX5043_DRGAIN3NB ;
__xdata volatile unsigned char __at(0x512E) AX5043_FOURFSK0NB ;
__xdata volatile unsigned char __at(0x513E) AX5043_FOURFSK1NB ;
__xdata volatile unsigned char __at(0x514E) AX5043_FOURFSK2NB ;
__xdata volatile unsigned char __at(0x515E) AX5043_FOURFSK3NB ;
__xdata volatile unsigned char __at(0x512D) AX5043_FREQDEV00NB ;
__xdata volatile unsigned char __at(0x513D) AX5043_FREQDEV01NB ;
__xdata volatile unsigned char __at(0x514D) AX5043_FREQDEV02NB ;
__xdata volatile unsigned char __at(0x515D) AX5043_FREQDEV03NB ;
__xdata volatile unsigned char __at(0x512C) AX5043_FREQDEV10NB ;
__xdata volatile unsigned char __at(0x513C) AX5043_FREQDEV11NB ;
__xdata volatile unsigned char __at(0x514C) AX5043_FREQDEV12NB ;
__xdata volatile unsigned char __at(0x515C) AX5043_FREQDEV13NB ;
__xdata volatile unsigned char __at(0x5127) AX5043_FREQUENCYGAINA0NB ;
__xdata volatile unsigned char __at(0x5137) AX5043_FREQUENCYGAINA1NB ;
__xdata volatile unsigned char __at(0x5147) AX5043_FREQUENCYGAINA2NB ;
__xdata volatile unsigned char __at(0x5157) AX5043_FREQUENCYGAINA3NB ;
__xdata volatile unsigned char __at(0x5128) AX5043_FREQUENCYGAINB0NB ;
__xdata volatile unsigned char __at(0x5138) AX5043_FREQUENCYGAINB1NB ;
__xdata volatile unsigned char __at(0x5148) AX5043_FREQUENCYGAINB2NB ;
__xdata volatile unsigned char __at(0x5158) AX5043_FREQUENCYGAINB3NB ;
__xdata volatile unsigned char __at(0x5129) AX5043_FREQUENCYGAINC0NB ;
__xdata volatile unsigned char __at(0x5139) AX5043_FREQUENCYGAINC1NB ;
__xdata volatile unsigned char __at(0x5149) AX5043_FREQUENCYGAINC2NB ;
__xdata volatile unsigned char __at(0x5159) AX5043_FREQUENCYGAINC3NB ;
__xdata volatile unsigned char __at(0x512A) AX5043_FREQUENCYGAIND0NB ;
__xdata volatile unsigned char __at(0x513A) AX5043_FREQUENCYGAIND1NB ;
__xdata volatile unsigned char __at(0x514A) AX5043_FREQUENCYGAIND2NB ;
__xdata volatile unsigned char __at(0x515A) AX5043_FREQUENCYGAIND3NB ;
__xdata volatile unsigned char __at(0x5116) AX5043_FREQUENCYLEAKNB ;
__xdata volatile unsigned char __at(0x5126) AX5043_PHASEGAIN0NB ;
__xdata volatile unsigned char __at(0x5136) AX5043_PHASEGAIN1NB ;
__xdata volatile unsigned char __at(0x5146) AX5043_PHASEGAIN2NB ;
__xdata volatile unsigned char __at(0x5156) AX5043_PHASEGAIN3NB ;
__xdata volatile unsigned char __at(0x5207) AX5043_PKTADDR0NB ;
__xdata volatile unsigned char __at(0x5206) AX5043_PKTADDR1NB ;
__xdata volatile unsigned char __at(0x5205) AX5043_PKTADDR2NB ;
__xdata volatile unsigned char __at(0x5204) AX5043_PKTADDR3NB ;
__xdata volatile unsigned char __at(0x5200) AX5043_PKTADDRCFGNB ;
__xdata volatile unsigned char __at(0x520B) AX5043_PKTADDRMASK0NB ;
__xdata volatile unsigned char __at(0x520A) AX5043_PKTADDRMASK1NB ;
__xdata volatile unsigned char __at(0x5209) AX5043_PKTADDRMASK2NB ;
__xdata volatile unsigned char __at(0x5208) AX5043_PKTADDRMASK3NB ;
__xdata volatile unsigned char __at(0x5201) AX5043_PKTLENCFGNB ;
__xdata volatile unsigned char __at(0x5202) AX5043_PKTLENOFFSETNB ;
__xdata volatile unsigned char __at(0x5203) AX5043_PKTMAXLENNB ;
__xdata volatile unsigned char __at(0x5118) AX5043_RXPARAMCURSETNB ;
__xdata volatile unsigned char __at(0x5117) AX5043_RXPARAMSETSNB ;
__xdata volatile unsigned char __at(0x5124) AX5043_TIMEGAIN0NB ;
__xdata volatile unsigned char __at(0x5134) AX5043_TIMEGAIN1NB ;
__xdata volatile unsigned char __at(0x5144) AX5043_TIMEGAIN2NB ;
__xdata volatile unsigned char __at(0x5154) AX5043_TIMEGAIN3NB ;
# 37 "..\\COMMON\\/easyax5043.h" 2
# 45 "..\\COMMON\\/easyax5043.h"
typedef enum {
    trxstate_off,
    trxstate_rx,
    trxstate_rxwor,
    trxstate_wait_xtal,
    trxstate_xtal_ready,
    trxstate_pll_ranging,
    trxstate_pll_ranging_done,
    trxstate_pll_settling,
    trxstate_pll_settled,
    trxstate_tx_xtalwait,
    trxstate_tx_longpreamble,
    trxstate_tx_shortpreamble,
    trxstate_tx_packet,
    trxstate_tx_waitdone,
    trxstate_txcw_xtalwait,
    trxstate_txstream_xtalwait,
    trxstate_txstream
} axradio_trxstate_t;




struct u32endian {
    uint8_t b0;
    uint8_t b1;
    uint8_t b2;
    uint8_t b3;
};

struct u16endian {
    uint8_t b0;
    uint8_t b1;
};
# 98 "..\\COMMON\\/easyax5043.h"
volatile extern axradio_trxstate_t __data axradio_trxstate;

extern uint8_t __data EASY_RADIO_ax5043_powermode_after_send_packet;
extern uint8_t __data EASY_RADIO_ax5043_powermode_after_rx_packet;


extern volatile uint8_t __data EASY_RADIO_saved_radiostate;




__xdata volatile unsigned char __at(0x4f00) AX5043_0xF00 ;
__xdata volatile unsigned char __at(0x4f01) AX5043_0xF01 ;
__xdata volatile unsigned char __at(0x4f0c) AX5043_0xF0C ;
__xdata volatile unsigned char __at(0x4f10) AX5043_0xF10 ;
__xdata volatile unsigned char __at(0x4f11) AX5043_0xF11 ;
__xdata volatile unsigned char __at(0x4f18) AX5043_0xF18 ;
__xdata volatile unsigned char __at(0x4f1c) AX5043_0xF1C ;
__xdata volatile unsigned char __at(0x4f21) AX5043_0xF21 ;
__xdata volatile unsigned char __at(0x4f22) AX5043_0xF22 ;
__xdata volatile unsigned char __at(0x4f23) AX5043_0xF23 ;
__xdata volatile unsigned char __at(0x4f26) AX5043_0xF26 ;
__xdata volatile unsigned char __at(0x4f2f) AX5043_0xF2F ;
__xdata volatile unsigned char __at(0x4f30) AX5043_0xF30 ;
__xdata volatile unsigned char __at(0x4f31) AX5043_0xF31 ;
__xdata volatile unsigned char __at(0x4f32) AX5043_0xF32 ;
__xdata volatile unsigned char __at(0x4f33) AX5043_0xF33 ;
__xdata volatile unsigned char __at(0x4f34) AX5043_0xF34 ;
__xdata volatile unsigned char __at(0x4f35) AX5043_0xF35 ;
__xdata volatile unsigned char __at(0x4f44) AX5043_0xF44 ;

__xdata volatile unsigned char __at(0x4f0d) AX5043_REF ;
__xdata volatile unsigned char __at(0x4f08) AX5043_POWCTRL1 ;
# 159 "..\\COMMON\\/easyax5043.h"
void axradio_wait_for_xtal(void);

 void ax5043_receiver_on_continuous(void) __reentrant;
 void ax5043_receiver_on_wor(void) __reentrant;
 void ax5043_off(void) __reentrant;
 void ax5043_off_xtal(void) __reentrant;
 void ax5043_prepare_tx(void) __reentrant;


 void ax5043_set_registers(void) __reentrant;
 void ax5043_set_registers_tx(void) __reentrant;
 void ax5043_set_registers_rx(void) __reentrant;
 uint8_t axradio_framing_check_crc(const __xdata uint8_t *pkt, uint16_t cnt) __reentrant;
 uint16_t axradio_framing_append_crc(__xdata uint8_t *pkt, uint16_t cnt) __reentrant;



extern const uint8_t __code axradio_phy_pn9;
extern const uint8_t __code axradio_phy_nrchannels;
extern const uint32_t __code axradio_phy_chanfreq[];
extern const uint8_t __code axradio_phy_chanpllrnginit[];
extern uint8_t __xdata axradio_phy_chanpllrng_rx[];
extern uint8_t __xdata axradio_phy_chanpllrng_tx[];
extern const int32_t __code axradio_phy_maxfreqoffset;
extern const int8_t __code axradio_phy_rssioffset;
extern const int8_t __code axradio_phy_rssireference;
extern const int8_t __code axradio_phy_channelbusy;
extern const uint8_t __code axradio_phy_cs_enabled;
extern const uint16_t __code axradio_phy_cs_period;
extern const uint8_t __code axradio_phy_lbt_retries;
extern const uint8_t __code axradio_phy_lbt_forcetx;
extern const uint8_t __code axradio_phy_tmgrxpreamble1_wor;
extern const uint8_t __code axradio_phy_tmgrxpreamble1_cont;

extern const uint16_t __code axradio_phy_preamble_wor_longlen;
extern const uint16_t __code axradio_phy_preamble_longlen;
extern const uint16_t __code axradio_phy_preamble_wor_len;
extern const uint16_t __code axradio_phy_preamble_len;
extern const uint8_t __code axradio_phy_preamble_byte;
extern const uint8_t __code axradio_phy_preamble_flags;
extern const uint8_t __code axradio_phy_preamble_appendbits;
extern const uint8_t __code axradio_phy_preamble_appendpattern;


extern const uint8_t __code axradio_framing_lenpos;
extern const uint8_t __code axradio_framing_lenoffs;
extern const uint8_t __code axradio_framing_lenmask;
extern const uint8_t __code axradio_framing_destaddrpos;
extern const uint8_t __code axradio_framing_sourceaddrpos;

extern const uint8_t __code axradio_framing_synclen;
extern const uint8_t __code axradio_framing_syncword[];
extern const uint8_t __code axradio_framing_syncflags;
extern const uint8_t __code axradio_framing_enable_sfdcallback;
extern const uint8_t __code axradio_framing_swcrclen;


extern const uint32_t __code axradio_framing_ack_timeout;
extern const uint32_t __code axradio_framing_ack_delay;
extern const uint8_t __code axradio_framing_ack_retransmissions;
extern const uint8_t __code axradio_framing_ack_seqnrpos;

extern const uint8_t __code axradio_framing_minpayloadlen;


extern const uint16_t __code axradio_wor_period;


extern const uint32_t __code axradio_sync_period;
extern const uint32_t __code axradio_sync_xoscstartup;

extern const uint32_t __code axradio_sync_slave_syncwindow;
extern const uint32_t __code axradio_sync_slave_initialsyncwindow;
extern const uint32_t __code axradio_sync_slave_syncpause;
extern const int16_t __code axradio_sync_slave_maxperiod;
extern const uint8_t __code axradio_sync_slave_resyncloss;
extern const uint8_t __code axradio_sync_slave_nrrx;
extern const uint32_t __code axradio_sync_slave_rxadvance[];
extern const uint32_t __code axradio_sync_slave_rxwindow[];
extern const uint32_t __code axradio_sync_slave_rxtimeout;
# 31 "..\\COMMON\\easyax5043.c" 2
# 1 "C://Program Files (x86)//AXSEM//AXSDB//libmf//include/libmfcrc.h" 1



# 1 "C://Program Files (x86)//AXSEM//AXSDB//libmf//include/libmftypes.h" 1
# 5 "C://Program Files (x86)//AXSEM//AXSDB//libmf//include/libmfcrc.h" 2




extern uint16_t crc_ccitt_byte(uint16_t crc, uint8_t c) __reentrant;
extern uint16_t crc_ccitt_msb_byte(uint16_t crc, uint8_t c) __reentrant;
extern uint16_t crc_ccitt(const uint8_t *buf, uint16_t buflen, uint16_t crc) __reentrant;
extern uint16_t crc_ccitt_msb(const uint8_t *buf, uint16_t buflen, uint16_t crc) __reentrant;
extern const uint16_t __code crc_ccitt_table[256];
extern const uint16_t __code crc_ccitt_msbtable[256];




extern uint16_t crc_crc16_byte(uint16_t crc, uint8_t c) __reentrant;
extern uint16_t crc_crc16_msb_byte(uint16_t crc, uint8_t c) __reentrant;
extern uint16_t crc_crc16(const uint8_t *buf, uint16_t buflen, uint16_t crc) __reentrant;
extern uint16_t crc_crc16_msb(const uint8_t *buf, uint16_t buflen, uint16_t crc) __reentrant;
extern const uint16_t __code crc_crc16_table[256];
extern const uint16_t __code crc_crc16_msbtable[256];




extern uint16_t crc_crc16dnp_byte(uint16_t crc, uint8_t c) __reentrant;
extern uint16_t crc_crc16dnp_msb_byte(uint16_t crc, uint8_t c) __reentrant;
extern uint16_t crc_crc16dnp(const uint8_t *buf, uint16_t buflen, uint16_t crc) __reentrant;
extern uint16_t crc_crc16dnp_msb(const uint8_t *buf, uint16_t buflen, uint16_t crc) __reentrant;
extern const uint16_t __code crc_crc16dnp_table[256];
extern const uint16_t __code crc_crc16dnp_msbtable[256];




extern uint32_t crc_crc32_byte(uint32_t crc, uint8_t c) __reentrant;
extern uint32_t crc_crc32_msb_byte(uint32_t crc, uint8_t c) __reentrant;
extern uint32_t crc_crc32(const uint8_t *buf, uint16_t buflen, uint32_t crc) __reentrant;
extern uint32_t crc_crc32_msb(const uint8_t *buf, uint16_t buflen, uint32_t crc) __reentrant;
extern const uint32_t __code crc_crc32_table[256];
extern const uint32_t __code crc_crc32_msbtable[256];




extern uint8_t crc8_ccitt_byte(uint8_t crc, uint8_t c) __reentrant;
extern uint8_t crc8_ccitt(const uint8_t *buf, uint8_t len, uint8_t init) __reentrant;




extern uint16_t pn9_advance(uint16_t pn9) __reentrant;
extern const uint8_t __code pn9_table[512];
extern uint16_t pn9_advance_bit(uint16_t pn9) __reentrant;
extern uint16_t pn9_advance_bits(uint16_t pn9, uint16_t bits) __reentrant;
extern uint16_t pn9_advance_byte(uint16_t pn9) __reentrant;
extern uint16_t pn9_buffer(uint8_t *buf, uint16_t buflen, uint16_t pn9, uint8_t xor) __reentrant;
# 32 "..\\COMMON\\easyax5043.c" 2
# 1 "C://Program Files (x86)//AXSEM//AXSDB//libmf//include/libmfradio.h" 1






#pragma callee_saves radio_read16,radio_read24,radio_read32,radio_write16,radio_write24,radio_write32

extern uint16_t radio_read16(uint16_t addr) __reentrant;
extern uint32_t radio_read24(uint16_t addr) __reentrant;
extern uint32_t radio_read32(uint16_t addr) __reentrant;
extern void radio_write16(uint16_t addr, uint16_t d) __reentrant;
extern void radio_write24(uint16_t addr, uint32_t d) __reentrant;
extern void radio_write32(uint16_t addr, uint32_t d) __reentrant;




extern void ax5031_comminit(void) __reentrant;
extern void ax5031_commsleepexit(void) __reentrant;
extern uint8_t ax5031_reset(void) __reentrant;
extern void ax5031_rclk_enable(uint8_t div) __reentrant;
extern void ax5031_rclk_disable(void) __reentrant;
extern void ax5031_readfifo(uint8_t *ptr, uint8_t len) __reentrant;
extern void ax5031_writefifo(const uint8_t *ptr, uint8_t len) __reentrant;




extern void ax5042_comminit(void) __reentrant;
extern void ax5042_commsleepexit(void) __reentrant;
extern uint8_t ax5042_reset(void) __reentrant;
extern void ax5042_rclk_enable(uint8_t div) __reentrant;
extern void ax5042_rclk_disable(void) __reentrant;
extern void ax5042_readfifo(uint8_t *ptr, uint8_t len) __reentrant;
extern void ax5042_writefifo(const uint8_t *ptr, uint8_t len) __reentrant;




extern void ax5043_comminit(void) __reentrant;
extern void ax5043_commsleepexit(void) __reentrant;
extern uint8_t ax5043_reset(void) __reentrant;
extern void ax5043_enter_deepsleep(void) __reentrant;
extern uint8_t ax5043_wakeup_deepsleep(void) __reentrant;
extern void ax5043_rclk_enable(uint8_t div) __reentrant;
extern void ax5043_rclk_disable(void) __reentrant;
extern void ax5043_readfifo(uint8_t *ptr, uint8_t len) __reentrant;
extern void ax5043_writefifo(const uint8_t *ptr, uint8_t len) __reentrant;




extern void ax5051_comminit(void) __reentrant;
extern void ax5051_commsleepexit(void) __reentrant;
extern uint8_t ax5051_reset(void) __reentrant;
extern void ax5051_rclk_enable(uint8_t div) __reentrant;
extern void ax5051_rclk_disable(void) __reentrant;
extern void ax5051_readfifo(uint8_t *ptr, uint8_t len) __reentrant;
extern void ax5051_writefifo(const uint8_t *ptr, uint8_t len) __reentrant;
# 33 "..\\COMMON\\easyax5043.c" 2
# 1 "C://Program Files (x86)//AXSEM//AXSDB//libmf//include/libmfwtimer.h" 1





struct wtimer_callback {


 struct wtimer_callback __xdata *next;
        void (*handler)(struct wtimer_callback __xdata *desc);
};

struct wtimer_desc {

 struct wtimer_desc __xdata *next;
        void (*handler)(struct wtimer_desc __xdata *desc);
 uint32_t time;
};
# 27 "C://Program Files (x86)//AXSEM//AXSDB//libmf//include/libmfwtimer.h"
extern void wtimer0_setconfig(uint8_t cfg) __reentrant;
extern void wtimer1_setconfig(uint8_t cfg) __reentrant;
# 42 "C://Program Files (x86)//AXSEM//AXSDB//libmf//include/libmfwtimer.h"
extern void wtimer_init(void) __reentrant;
extern uint8_t wtimer_idle(uint8_t flags) __reentrant;





extern uint8_t wtimer_runcallbacks(void) __reentrant;


extern uint32_t wtimer0_curtime(void) __reentrant;
extern uint32_t wtimer1_curtime(void) __reentrant;
extern void wtimer0_addabsolute(struct wtimer_desc __xdata *desc) __reentrant;
extern void wtimer1_addabsolute(struct wtimer_desc __xdata *desc) __reentrant;
extern void wtimer0_addrelative(struct wtimer_desc __xdata *desc) __reentrant;
extern void wtimer1_addrelative(struct wtimer_desc __xdata *desc) __reentrant;
extern uint8_t wtimer_remove(struct wtimer_desc __xdata *desc) __reentrant;
extern uint8_t wtimer0_remove(struct wtimer_desc __xdata *desc) __reentrant;
extern uint8_t wtimer1_remove(struct wtimer_desc __xdata *desc) __reentrant;

extern void wtimer_add_callback(struct wtimer_callback __xdata *desc) __reentrant;
extern uint8_t wtimer_remove_callback(struct wtimer_callback __xdata *desc) __reentrant;

extern uint8_t wtimer_cansleep(void) __reentrant;


extern void wtimer_irq(void) __interrupt(1);
# 34 "..\\COMMON\\easyax5043.c" 2
# 1 "C://Program Files (x86)//SDCC//include/stdlib.h" 1
# 36 "C://Program Files (x86)//SDCC//include/stdlib.h"
# 1 "C://Program Files (x86)//SDCC//include/malloc.h" 1
# 31 "C://Program Files (x86)//SDCC//include/malloc.h"
# 1 "C://Program Files (x86)//SDCC//include/sdcc-lib.h" 1
# 49 "C://Program Files (x86)//SDCC//include/sdcc-lib.h"
# 1 "C://Program Files (x86)//SDCC//include/asm/mcs51/features.h" 1
# 50 "C://Program Files (x86)//SDCC//include/sdcc-lib.h" 2
# 32 "C://Program Files (x86)//SDCC//include/malloc.h" 2
# 1 "C://Program Files (x86)//SDCC//include/stddef.h" 1
# 40 "C://Program Files (x86)//SDCC//include/stddef.h"
  typedef long int ptrdiff_t;







  typedef unsigned int size_t;




  typedef char wchar_t;
# 33 "C://Program Files (x86)//SDCC//include/malloc.h" 2
# 43 "C://Program Files (x86)//SDCC//include/malloc.h"
extern void __xdata * calloc (size_t nmemb, size_t size);
extern void __xdata * malloc (size_t size);
extern void __xdata * realloc (void * ptr, size_t size);
extern void free (void * ptr);
# 37 "C://Program Files (x86)//SDCC//include/stdlib.h" 2

int abs(int j);
long int labs(long int j);

extern float atof (const char *);
extern int atoi (const char *);
extern long atol (const char *);

extern void _uitoa(unsigned int, char*, unsigned char);
extern void _itoa(int, char*, unsigned char);

extern void _ultoa(unsigned long, char*, unsigned char);
extern void _ltoa(long, char*, unsigned char);



int rand(void);
void srand(unsigned int seed);
# 35 "..\\COMMON\\easyax5043.c" 2
# 1 "C://Program Files (x86)//SDCC//include/string.h" 1
# 66 "C://Program Files (x86)//SDCC//include/string.h"
extern void *memcpy (void * dest, const void * src, size_t n);
extern void *memmove (void *dest, const void *src, size_t n);
extern char *strcpy (char * dest, const char * src);
extern char *strncpy(char * dest, const char * src, size_t n);


extern char *strcat (char * dest, const char * src);
extern char *strncat(char * dest, const char * src, size_t n);


extern int memcmp (const void *s1, const void *s2, size_t n);
extern int strcmp (const char *s1, const char *s2);


extern int strncmp(const char *s1, const char *s2, size_t n);
extern size_t strxfrm(char *dest, const char *src, size_t n);


extern void *memchr (const void *s, int c, size_t n);

extern char *strchr (const char *s, char c);



extern size_t strcspn(const char *s, const char *reject);
extern char *strpbrk(const char *s, const char *accept);

extern char *strrchr(const char *s, char c);



extern size_t strspn (const char *s, const char *accept);
extern char *strstr (const char *haystack, const char *needle);
extern char *strtok (char * str, const char * delim);



extern void *memset (void *s, unsigned char c, size_t n);





extern size_t strlen (const char *s);
# 36 "..\\COMMON\\easyax5043.c" 2
# 1 "C://Program Files (x86)//AXSEM//AXSDB//libmf//include/libmfdbglink.h" 1
# 88 "C://Program Files (x86)//AXSEM//AXSDB//libmf//include/libmfdbglink.h"
#pragma callee_saves dbglink_txbufptr,dbglink_txfreelinear,dbglink_rxbufptr,dbglink_rxcountlinear
#pragma callee_saves dbglink_txfree,dbglink_rxcount,dbglink_wait_txfree,dbglink_wait_rxcount
#pragma callee_saves dbglink_txbuffersize,dbglink_rxbuffersize,dbglink_rxpeek,dbglink_txpoke,dbglink_txpokehex
#pragma callee_saves dbglink_init,dbglink_poll,dbglink_wait_txfree,dbglink_wait_rxcount,dbglink_rx,dbglink_tx
extern void dbglink_irq(void) __interrupt(21) __naked;






extern uint8_t dbglink_poll(void) __reentrant __naked;
extern uint8_t __xdata *dbglink_txbufptr(uint8_t idx) __reentrant __naked;
extern uint8_t dbglink_txfreelinear(void) __reentrant __naked;
extern uint8_t dbglink_txidle(void) __reentrant __naked;
extern uint8_t dbglink_txfree(void) __reentrant __naked;
extern const uint8_t __xdata *dbglink_rxbufptr(uint8_t idx) __reentrant __naked;
extern uint8_t dbglink_rxcountlinear(void) __reentrant __naked;
extern uint8_t dbglink_rxcount(void) __reentrant __naked;
extern uint8_t dbglink_txbuffersize(void) __reentrant __naked;
extern uint8_t dbglink_rxbuffersize(void) __reentrant __naked;
extern uint8_t dbglink_rxpeek(uint8_t idx) __reentrant __naked;
extern void dbglink_txpoke(uint8_t idx, uint8_t ch) __reentrant __naked;
extern void dbglink_txpokehex(uint8_t idx, uint8_t ch) __reentrant __naked;
extern void dbglink_rxadvance(uint8_t idx) __reentrant __naked;
extern void dbglink_txadvance(uint8_t idx) __reentrant __naked;

extern void dbglink_init(void) __reentrant;
extern void dbglink_wait_txdone(void) __reentrant;
extern void dbglink_wait_txfree(uint8_t v) __reentrant;
extern void dbglink_wait_rxcount(uint8_t v) __reentrant;
extern uint8_t dbglink_rx(void) __reentrant;
extern void dbglink_tx(uint8_t v) __reentrant;
extern void dbglink_writestr(const char *ch) __reentrant;
extern uint8_t dbglink_writenum16(uint16_t val, uint8_t nrdig, uint8_t flags) __reentrant;
extern uint8_t dbglink_writehex16(uint16_t val, uint8_t nrdig, uint8_t flags) __reentrant;

extern uint8_t dbglink_writenum32(uint32_t val, uint8_t nrdig, uint8_t flags) __reentrant;
extern uint8_t dbglink_writehex32(uint32_t val, uint8_t nrdig, uint8_t flags) __reentrant;






extern void dbglink_writehexu16(uint16_t val, uint8_t nrdig) __reentrant;
extern void dbglink_writehexu32(uint32_t val, uint8_t nrdig);
extern void dbglink_writeu16(uint16_t val, uint8_t nrdig) __reentrant;
extern void dbglink_writeu32(uint32_t val, uint8_t nrdig);
# 37 "..\\COMMON\\easyax5043.c" 2


typedef enum {
    syncstate_off,
    syncstate_lbt,
    syncstate_asynctx,
    syncstate_master_normal,
    syncstate_master_xostartup,
    syncstate_master_waitack,
    syncstate_slave_synchunt,
    syncstate_slave_syncpause,
    syncstate_slave_rxidle,
    syncstate_slave_rxxosc,
    syncstate_slave_rxsfdwindow,
    syncstate_slave_rxpacket,
    syncstate_slave_rxack
} axradio_syncstate_t;

volatile uint8_t __data axradio_mode = 0x00;
volatile axradio_trxstate_t __data axradio_trxstate = trxstate_off;
volatile axradio_syncstate_t __xdata axradio_syncstate;
uint16_t __xdata axradio_txbuffer_len;
uint16_t __xdata axradio_txbuffer_cnt;
uint8_t __xdata axradio_curchannel;
int32_t __xdata axradio_curfreqoffset;
uint8_t __xdata axradio_ack_count;
uint8_t __xdata axradio_ack_seqnr;

uint32_t __xdata axradio_sync_time;
int16_t __xdata axradio_sync_periodcorr;
struct {
    uint32_t timer0;
    uint32_t radiotimer;
} __xdata axradio_timeanchor;
struct axradio_address_mask __xdata axradio_localaddr;
struct axradio_address __xdata axradio_default_remoteaddr;




uint8_t __xdata axradio_txbuffer[260];
uint8_t __xdata axradio_rxbuffer[260];

struct axradio_callback_simple {
    struct wtimer_callback cb;
    struct {
        uint8_t status;
        uint8_t error;
        union {
            uint32_t t;
            struct u32endian b;
        } time;
    } st;
};

struct axradio_callback_receive {
    struct wtimer_callback cb;
    struct {
        uint8_t status;
        uint8_t error;
        union {
            uint32_t t;
            struct u32endian b;
        } time;
        struct {
            struct {
                int16_t rssi;
                union {
                    int32_t o;
                    struct u32endian b;
                } offset;
                int16_t timeoffset;
                int16_t period;
            } phy;
            struct axradio_status_receive_mac mac;
            const __xdata uint8_t *pktdata;
            uint16_t pktlen;
        } rx;
    } st;
};

struct axradio_callback_channelstate {
    struct wtimer_callback cb;
    struct {
        uint8_t status;
        uint8_t error;
        union {
            uint32_t t;
            struct u32endian b;
        } time;
        struct axradio_status_channelstate cs;
    } st;
};

struct axradio_callback_receive __xdata axradio_cb_receive;
struct axradio_callback_simple __xdata axradio_cb_receivesfd;
struct axradio_callback_channelstate __xdata axradio_cb_channelstate;
struct axradio_callback_simple __xdata axradio_cb_transmitstart;
struct axradio_callback_simple __xdata axradio_cb_transmitend;
struct axradio_callback_simple __xdata axradio_cb_transmitdata;
struct wtimer_desc __xdata axradio_timer;

volatile uint8_t __xdata f30_saved = 0x3f;
volatile uint8_t __xdata f31_saved = 0xf0;
volatile uint8_t __xdata f32_saved = 0x3f;
volatile uint8_t __xdata f33_saved = 0xf0;
# 234 "..\\COMMON\\easyax5043.c"
static void update_timeanchor(void) __reentrant
{
    uint8_t iesave = IE & 0x80;
    EA = 0;
    axradio_timeanchor.timer0 = wtimer0_curtime();
    axradio_timeanchor.radiotimer = radio_read24((uint16_t)&AX5043_TIMER2);
    IE |= iesave;
}

 uint32_t axradio_conv_time_totimer0(uint32_t dt) __reentrant
{
    dt -= axradio_timeanchor.radiotimer;
    dt = axradio_conv_timeinterval_totimer0(signextend24(dt));
    dt += axradio_timeanchor.timer0;
    return dt;
}

 uint8_t ax5043_init_registers_tx(void) __reentrant
{
    uint8_t rng;
    ax5043_set_registers_tx();
    rng = axradio_phy_chanpllrng_tx[axradio_curchannel];
    if (rng & 0x20)
        return 0x06;
    if (AX5043_PLLLOOP & 0x80) {
        AX5043_PLLRANGINGB = rng & 0x0F;
    } else {
        AX5043_PLLRANGINGA = rng & 0x0F;
    }
    return 0x00;
}

 uint8_t ax5043_init_registers_rx(void) __reentrant
{
    uint8_t rng;
    ax5043_set_registers_rx();
    rng = axradio_phy_chanpllrng_rx[axradio_curchannel];
    if (rng & 0x20)
        return 0x06;
    if (AX5043_PLLLOOP & 0x80) {
        AX5043_PLLRANGINGB = rng & 0x0F;
    } else {
        AX5043_PLLRANGINGA = rng & 0x0F;
    }
    return 0x00;
}

static void receive_isr(void) __reentrant
{
    uint8_t fifo_cmd, flags;
    uint8_t i;
    uint8_t len = AX5043_RADIOEVENTREQ0;

    if ((len & 0x04) && AX5043_RADIOSTATE == 0x0F) {

        update_timeanchor();
        if(axradio_framing_enable_sfdcallback)
        {
            wtimer_remove_callback(&axradio_cb_receivesfd.cb);
            axradio_cb_receivesfd.st.error = 0x00;
            axradio_cb_receivesfd.st.time.t = axradio_timeanchor.radiotimer;
            wtimer_add_callback(&axradio_cb_receivesfd.cb);
        }
    }
# 307 "..\\COMMON\\easyax5043.c"
    while (AX5043_IRQREQUEST0 & 0x01) {
        fifo_cmd = AX5043_FIFODATA;
        len = (fifo_cmd & 0xE0) >> 5;
        if (len == 7)
            len = AX5043_FIFODATA;
        fifo_cmd &= 0x1F;
        switch (fifo_cmd) {
        case 0x01:
            if (!len)
                break;






            flags = AX5043_FIFODATA;
            --len;
            ax5043_readfifo(axradio_rxbuffer, len);
            if(axradio_mode == 0x19 || axradio_mode == 0x1b)
            {
                f30_saved = AX5043_0xF30;
                f31_saved = AX5043_0xF31;
                f32_saved = AX5043_0xF32;
                f33_saved = AX5043_0xF33;
            }
            if (axradio_mode == 0x19 ||
                axradio_mode == 0x22)
                AX5043_PWRMODE = 0x0;
            AX5043_IRQMASK0 &= (uint8_t)~0x01;
            wtimer_remove_callback(&axradio_cb_receive.cb);
            axradio_cb_receive.st.error = 0x00;
            axradio_cb_receive.st.rx.mac.raw = axradio_rxbuffer;
            if (axradio_mode == 0x1c ||
                axradio_mode == 0x1d ||
                axradio_mode == 0x1e) {
                axradio_cb_receive.st.rx.pktdata = axradio_rxbuffer;
                axradio_cb_receive.st.rx.pktlen = len;
                {
                    int8_t r = AX5043_RSSI;
                    axradio_cb_receive.st.rx.phy.rssi = r - (int16_t)axradio_phy_rssioffset;
                }
                axradio_cb_receive.st.rx.phy.offset.o = signextend20(radio_read24((uint16_t)&AX5043_TRKRFFREQ2));
                wtimer_add_callback(&axradio_cb_receive.cb);
                break;
            }
            axradio_cb_receive.st.rx.pktdata = &axradio_rxbuffer[axradio_framing_maclen];
            if (len < axradio_framing_maclen) {
                len = 0;
                axradio_cb_receive.st.rx.pktlen = 0;
            } else {
                len -= axradio_framing_maclen;
                axradio_cb_receive.st.rx.pktlen = len;
                wtimer_add_callback(&axradio_cb_receive.cb);
                if (axradio_mode == 0x22 ||
                    axradio_mode == 0x23)
                    wtimer_remove(&axradio_timer);
            }
            break;

        case 0x13:
            if (len != 3)
                goto dropchunk;
            i = AX5043_FIFODATA;
            i &= 0x0F;
            i |= 1 + (uint8_t)~(i & 0x08);
            axradio_cb_receive.st.rx.phy.offset.b.b3 = ((int8_t)i) >> 8;
            axradio_cb_receive.st.rx.phy.offset.b.b2 = i;
            axradio_cb_receive.st.rx.phy.offset.b.b1 = AX5043_FIFODATA;
            axradio_cb_receive.st.rx.phy.offset.b.b0 = AX5043_FIFODATA;
            break;

        case 0x11:
            if (len != 1)
                goto dropchunk;
            {
                int8_t r = AX5043_FIFODATA;
                axradio_cb_receive.st.rx.phy.rssi = r - (int16_t)axradio_phy_rssioffset;
            }
            break;

        case 0x10:
            if (len != 3)
                goto dropchunk;


            axradio_cb_receive.st.time.b.b3 = 0;
            axradio_cb_receive.st.time.b.b2 = AX5043_FIFODATA;
            axradio_cb_receive.st.time.b.b1 = AX5043_FIFODATA;
            axradio_cb_receive.st.time.b.b0 = AX5043_FIFODATA;
            break;

        case 0x15:
            if (!len)
                break;
            update_timeanchor();
            wtimer_remove_callback(&axradio_cb_channelstate.cb);
            axradio_cb_channelstate.st.error = 0x00;
            {
                int8_t r = AX5043_FIFODATA;
                axradio_cb_channelstate.st.cs.rssi = r - (int16_t)axradio_phy_rssioffset;
                axradio_cb_channelstate.st.cs.busy = r >= axradio_phy_channelbusy;
            }
            axradio_cb_channelstate.st.time.t = axradio_timeanchor.radiotimer;
            wtimer_add_callback(&axradio_cb_channelstate.cb);
            --len;
            goto dropchunk;

        default:

dropchunk:
            if (!len)
                break;
            i = len;
            do {
                AX5043_FIFODATA;
            }
            while (--i);
            break;
        }
    }
}

static void transmit_isr(void) __reentrant
{
    for (;;) {
        uint8_t cnt = AX5043_FIFOFREE0;
        if (AX5043_FIFOFREE1)
            cnt = 0xff;
        switch (axradio_trxstate) {
        case trxstate_tx_longpreamble:
            if (!axradio_txbuffer_cnt) {
                axradio_trxstate = trxstate_tx_shortpreamble;
                if( axradio_mode == 0x11 || axradio_mode == 0x13 )
                    axradio_txbuffer_cnt = axradio_phy_preamble_wor_len;
                else
                    axradio_txbuffer_cnt = axradio_phy_preamble_len;
                goto shortpreamble;
            }
            if (cnt < 4)
                goto fifocommit;
            cnt = 7;
            if (axradio_txbuffer_cnt < 7)
                cnt = axradio_txbuffer_cnt;
            axradio_txbuffer_cnt -= cnt;
            cnt <<= 5;
            AX5043_FIFODATA = 0x02 | (3 << 5);
            AX5043_FIFODATA = axradio_phy_preamble_flags;
            AX5043_FIFODATA = cnt;
            AX5043_FIFODATA = axradio_phy_preamble_byte;
            break;

        case trxstate_tx_shortpreamble:
        shortpreamble:
            if (!axradio_txbuffer_cnt) {
                if (cnt < 15)
                    goto fifocommit;
                if (axradio_phy_preamble_appendbits) {
                    uint8_t byte;
                    AX5043_FIFODATA = 0x01 | (2 << 5);
                    AX5043_FIFODATA = 0x1C;
                    byte = axradio_phy_preamble_appendpattern;
                    if (AX5043_PKTADDRCFG & 0x80) {

                        byte &= 0xFF << (8-axradio_phy_preamble_appendbits);
                        byte |= 0x80 >> axradio_phy_preamble_appendbits;
                    } else {

                        byte &= 0xFF >> (8-axradio_phy_preamble_appendbits);
                        byte |= 0x01 << axradio_phy_preamble_appendbits;
                    }
                    AX5043_FIFODATA = byte;
                }




                if ((AX5043_FRAMING & 0x0E) == 0x06 && axradio_framing_synclen) {

                    uint8_t len_byte = axradio_framing_synclen;
                    uint8_t i = (len_byte & 0x07) ? 0x04 : 0;

                    len_byte += 7;
                    len_byte >>= 3;
                    AX5043_FIFODATA = 0x01 | ((len_byte + 1) << 5);
                    AX5043_FIFODATA = axradio_framing_syncflags | i;
                    for (i = 0; i < len_byte; ++i) {

                        AX5043_FIFODATA = axradio_framing_syncword[i];
                    }
                }




                axradio_trxstate = trxstate_tx_packet;
                break;
            }
            if (cnt < 4)
                goto fifocommit;
            cnt = 255;
            if (axradio_txbuffer_cnt < 255*8)
                cnt = axradio_txbuffer_cnt >> 3;
            if (cnt) {
                axradio_txbuffer_cnt -= ((uint16_t)cnt) << 3;
                AX5043_FIFODATA = 0x02 | (3 << 5);
                AX5043_FIFODATA = axradio_phy_preamble_flags;
                AX5043_FIFODATA = cnt;
                AX5043_FIFODATA = axradio_phy_preamble_byte;
                break;
            }
            {
                uint8_t byte = axradio_phy_preamble_byte;
                cnt = axradio_txbuffer_cnt;
                axradio_txbuffer_cnt = 0;
                AX5043_FIFODATA = 0x01 | (2 << 5);
                AX5043_FIFODATA = 0x1C;
                if (AX5043_PKTADDRCFG & 0x80) {

                    byte &= 0xFF << (8-cnt);
                    byte |= 0x80 >> cnt;
                } else {

                    byte &= 0xFF >> (8-cnt);
                    byte |= 0x01 << cnt;
                }
                AX5043_FIFODATA = byte;
            }
            break;

        case trxstate_tx_packet:
            if (cnt < 11)
                goto fifocommit;
            {
                uint8_t flags = 0;
                if (!axradio_txbuffer_cnt)
                    flags |= 0x01;
                {
                    uint16_t len = axradio_txbuffer_len - axradio_txbuffer_cnt;
                    cnt -= 3;
                    if (cnt >= len) {
                        cnt = len;
                        flags |= 0x02;
                    }
                }
                if (!cnt)
                    goto pktend;
                AX5043_FIFODATA = 0x01 | (7 << 5);
                AX5043_FIFODATA = cnt + 1;
                AX5043_FIFODATA = flags;
                ax5043_writefifo(&axradio_txbuffer[axradio_txbuffer_cnt], cnt);
                axradio_txbuffer_cnt += cnt;
                if (flags & 0x02)
                    goto pktend;
            }
            break;

        default:
            return;
        }
    }
pktend:
    axradio_trxstate = trxstate_tx_waitdone;
    AX5043_RADIOEVENTMASK0 = 0x01;
    AX5043_IRQMASK0 = 0x40;
fifocommit:
    AX5043_FIFOSTAT = 4;
}


void axradio_isr(void) __interrupt 4
# 586 "..\\COMMON\\easyax5043.c"
{
    switch (axradio_trxstate) {
    default:
        AX5043_IRQMASK1 = 0x00;
        AX5043_IRQMASK0 = 0x00;
        break;

    case trxstate_wait_xtal:
        AX5043_IRQMASK1 = 0x00;
        axradio_trxstate = trxstate_xtal_ready;
        break;

    case trxstate_pll_ranging:
        AX5043_IRQMASK1 = 0x00;
        axradio_trxstate = trxstate_pll_ranging_done;
        break;

    case trxstate_pll_settling:
        AX5043_RADIOEVENTMASK0 = 0x00;
        axradio_trxstate = trxstate_pll_settled;
        break;

    case trxstate_tx_xtalwait:
        AX5043_RADIOEVENTREQ0;
        AX5043_FIFOSTAT = 3;
        AX5043_IRQMASK1 = 0x00;
        AX5043_IRQMASK0 = 0x08;
        axradio_trxstate = trxstate_tx_longpreamble;

        if ((AX5043_MODULATION & 0x0F) == 9) {
            AX5043_FIFODATA = 0x01 | (7 << 5);
            AX5043_FIFODATA = 2;
            AX5043_FIFODATA = 0x01;
            AX5043_FIFODATA = 0x11;
        }





        transmit_isr();
        AX5043_PWRMODE = 0xd;
        update_timeanchor();
        wtimer_remove_callback(&axradio_cb_transmitstart.cb);
        switch (axradio_mode) {
        case 0x12:
        case 0x13:
            if (axradio_ack_count != axradio_framing_ack_retransmissions) {
                axradio_cb_transmitstart.st.error = 0x08;
                break;
            }

        default:
            axradio_cb_transmitstart.st.error = 0x00;
            break;
        }
        axradio_cb_transmitstart.st.time.t = axradio_timeanchor.radiotimer;
        wtimer_add_callback(&axradio_cb_transmitstart.cb);
        break;

    case trxstate_tx_longpreamble:
    case trxstate_tx_shortpreamble:
    case trxstate_tx_packet:
        transmit_isr();
        break;

    case trxstate_tx_waitdone:
        AX5043_RADIOEVENTREQ0;
        if (AX5043_RADIOSTATE != 0)
            break;
        AX5043_RADIOEVENTMASK0 = 0x00;
        switch (axradio_mode) {
        case 0x18:
            ax5043_init_registers_rx();
            ax5043_receiver_on_continuous();
            break;

        case 0x1a:
            if (axradio_cb_receive.st.error == 0xf0) {
                ax5043_init_registers_rx();
                ax5043_receiver_on_continuous();
                break;
            }
        offxtal:
            ax5043_off_xtal();
            break;

        case 0x19:
            if (axradio_cb_receive.st.error == 0xf0) {
                ax5043_init_registers_rx();
                ax5043_receiver_on_wor();
                break;
            }
            goto offxtal;

        case 0x1b:
            ax5043_init_registers_rx();
            ax5043_receiver_on_wor();
            break;

        case 0x21:
            axradio_txbuffer_len = axradio_framing_minpayloadlen;


        case 0x12:
        case 0x13:
            ax5043_init_registers_rx();
            ax5043_receiver_on_continuous();
            wtimer_remove(&axradio_timer);
            axradio_timer.time = axradio_framing_ack_timeout;
            wtimer0_addrelative(&axradio_timer);
            break;

        case 0x20:
            axradio_txbuffer_len = axradio_framing_minpayloadlen;


        default:
            ax5043_off();
            break;
        }
        if (axradio_mode != 0x20 &&
            axradio_mode != 0x21 &&
            axradio_mode != 0x22 &&
            axradio_mode != 0x23)
            axradio_syncstate = syncstate_off;
        update_timeanchor();
        wtimer_remove_callback(&axradio_cb_transmitend.cb);
        axradio_cb_transmitend.st.error = 0x00;
        if (axradio_mode == 0x12 ||
            axradio_mode == 0x13 ||
            axradio_mode == 0x21)
            axradio_cb_transmitend.st.error = 0x02;
        axradio_cb_transmitend.st.time.t = axradio_timeanchor.radiotimer;
        wtimer_add_callback(&axradio_cb_transmitend.cb);
        break;


    case trxstate_txcw_xtalwait:
        AX5043_IRQMASK1 = 0x00;
        AX5043_IRQMASK0 = 0x00;
        AX5043_PWRMODE = 0xd;
        axradio_trxstate = trxstate_off;
        update_timeanchor();
        wtimer_remove_callback(&axradio_cb_transmitstart.cb);
        axradio_cb_transmitstart.st.error = 0x00;
        axradio_cb_transmitstart.st.time.t = axradio_timeanchor.radiotimer;
        wtimer_add_callback(&axradio_cb_transmitstart.cb);
        break;

    case trxstate_txstream_xtalwait:
        if (AX5043_IRQREQUEST1 & 0x01) {
            AX5043_RADIOEVENTMASK0 = 0x03;
            AX5043_IRQMASK1 = 0x00;
            AX5043_IRQMASK0 = 0x40;
            AX5043_PWRMODE = 0xd;
            axradio_trxstate = trxstate_txstream;
        }
        goto txstreamdatacb;

    case trxstate_txstream:
        {
            uint8_t __data evt = AX5043_RADIOEVENTREQ0;
            if (evt & 0x03)
                update_timeanchor();
            if (evt & 0x01) {
                wtimer_remove_callback(&axradio_cb_transmitend.cb);
                axradio_cb_transmitend.st.error = 0x00;
                axradio_cb_transmitend.st.time.t = axradio_timeanchor.radiotimer;
                wtimer_add_callback(&axradio_cb_transmitend.cb);
            }
            if (evt & 0x02) {
                wtimer_remove_callback(&axradio_cb_transmitstart.cb);
                axradio_cb_transmitstart.st.error = 0x00;
                axradio_cb_transmitstart.st.time.t = axradio_timeanchor.radiotimer;
                wtimer_add_callback(&axradio_cb_transmitstart.cb);
            }
        }
    txstreamdatacb:
        if (AX5043_IRQREQUEST0 & AX5043_IRQMASK0 & 0x08) {
            AX5043_IRQMASK0 &= (uint8_t)~0x08;
            update_timeanchor();
            wtimer_remove_callback(&axradio_cb_transmitdata.cb);
            axradio_cb_transmitdata.st.error = 0x00;
            axradio_cb_transmitdata.st.time.t = axradio_timeanchor.radiotimer;
            wtimer_add_callback(&axradio_cb_transmitdata.cb);
        }
        break;

    case trxstate_rxwor:
        if( AX5043_IRQREQUEST1 & 0x01 )
        {
            AX5043_IRQINVERSION1 |= 0x01;
        }
        else
        {
            AX5043_IRQINVERSION1 &= ~0x01;
            AX5043_0xF30 = f30_saved;
            AX5043_0xF31 = f31_saved;
            AX5043_0xF32 = f32_saved;
            AX5043_0xF33 = f33_saved;
        }


    case trxstate_rx:
        receive_isr();
        break;

    }
}


 void ax5043_receiver_on_continuous(void) __reentrant
{
    uint8_t rschanged_int = (axradio_framing_enable_sfdcallback | (axradio_mode == 0x23) | (axradio_mode == 0x22) );
    if(rschanged_int)
        AX5043_RADIOEVENTMASK0 = 0x04;
    AX5043_RSSIREFERENCE = axradio_phy_rssireference;
    if (axradio_mode == 0x18 ||
        axradio_mode == 0x1a ||
        axradio_mode == 0x1c ||
        axradio_mode == 0x1d ||
        axradio_mode == 0x1e) {
        AX5043_TMGRXPREAMBLE1 = axradio_phy_tmgrxpreamble1_cont;
        AX5043_PKTSTOREFLAGS |= 0x40;
    } else {
        AX5043_TMGRXPREAMBLE1 = 0x00;
        AX5043_PKTSTOREFLAGS &= (uint8_t)~0x40;
    }
    AX5043_FIFOSTAT = 3;
    AX5043_PWRMODE = 0x9;
    axradio_trxstate = trxstate_rx;
    if(rschanged_int)
        AX5043_IRQMASK0 = 0x41;
    else
        AX5043_IRQMASK0 = 0x01;
    AX5043_IRQMASK1 = 0x00;
}

 void ax5043_receiver_on_wor(void) __reentrant
{
    AX5043_BGNDRSSIGAIN = 0x02;
    if(axradio_framing_enable_sfdcallback)
        AX5043_RADIOEVENTMASK0 = 0x04;
    AX5043_FIFOSTAT = 3;
    AX5043_LPOSCCONFIG = 0x01;
    AX5043_TMGRXPREAMBLE1 = axradio_phy_tmgrxpreamble1_wor;
    AX5043_RSSIREFERENCE = axradio_phy_rssireference;
    AX5043_PWRMODE = 0xb;
    axradio_trxstate = trxstate_rxwor;
    if(axradio_framing_enable_sfdcallback)
        AX5043_IRQMASK0 = 0x41;
    else
        AX5043_IRQMASK0 = 0x01;
    AX5043_IRQMASK1 = 0x01;
    {
        uint16_t wp = axradio_wor_period;
        AX5043_WAKEUPFREQ1 = (wp >> 8) & 0xFF;
        AX5043_WAKEUPFREQ0 = (wp >> 0) & 0xFF;
        wp += radio_read16((uint16_t)&AX5043_WAKEUPTIMER1);
        AX5043_WAKEUP1 = (wp >> 8) & 0xFF;
        AX5043_WAKEUP0 = (wp >> 0) & 0xFF;
    }
}
 void ax5043_prepare_tx(void) __reentrant
{
    AX5043_PWRMODE = 0x5;
    AX5043_PWRMODE = 0x7;
    ax5043_init_registers_tx();
    AX5043_FIFOTHRESH1 = 0;
    AX5043_FIFOTHRESH0 = 0x80;
    axradio_trxstate = trxstate_tx_xtalwait;
    AX5043_IRQMASK0 = 0x00;
    AX5043_IRQMASK1 = 0x01;
}

 void ax5043_off(void) __reentrant
{
    ax5043_off_xtal();
    AX5043_PWRMODE = 0x0;
}

 void ax5043_off_xtal(void) __reentrant
{
    AX5043_IRQMASK0 = 0x00;
    AX5043_IRQMASK1 = 0x00;
    AX5043_PWRMODE = 0x5;
    AX5043_LPOSCCONFIG = 0x00;
    axradio_trxstate = trxstate_off;
}

void axradio_wait_for_xtal(void)
{
    uint8_t __data iesave = IE & 0x80;
    EA = 0;
    axradio_trxstate = trxstate_wait_xtal;
    AX5043_IRQMASK1 |= 0x01;
    for(;;) {
        EA = 0;
        if (axradio_trxstate == trxstate_xtal_ready)
            break;
        wtimer_idle(0x02);
        EA = 1;
        wtimer_runcallbacks();
    }
    IE |= iesave;
}

static void axradio_setaddrregs(void)
{
    AX5043_PKTADDR0 = axradio_localaddr.addr[0];
    AX5043_PKTADDR1 = axradio_localaddr.addr[1];
    AX5043_PKTADDR2 = axradio_localaddr.addr[2];
    AX5043_PKTADDR3 = axradio_localaddr.addr[3];

    AX5043_PKTADDRMASK0 = axradio_localaddr.mask[0];
    AX5043_PKTADDRMASK1 = axradio_localaddr.mask[1];
    AX5043_PKTADDRMASK2 = axradio_localaddr.mask[2];
    AX5043_PKTADDRMASK3 = axradio_localaddr.mask[3];

    if (axradio_phy_pn9 && axradio_framing_addrlen) {
        uint16_t __data pn = 0x1ff;
        uint8_t __data inv = -(AX5043_ENCODING & 0x01);
        if (axradio_framing_destaddrpos != 0xff)
            pn = pn9_advance_bits(pn, axradio_framing_destaddrpos << 3);
        AX5043_PKTADDR0 ^= pn ^ inv;
        pn = pn9_advance_byte(pn);
        AX5043_PKTADDR1 ^= pn ^ inv;
        pn = pn9_advance_byte(pn);
        AX5043_PKTADDR2 ^= pn ^ inv;
        pn = pn9_advance_byte(pn);
        AX5043_PKTADDR3 ^= pn ^ inv;
    }
}

static void ax5043_init_registers(void)
{
    ax5043_set_registers();




    AX5043_PKTLENOFFSET += axradio_framing_swcrclen;
    AX5043_PINFUNCIRQ = 0x03;
    AX5043_PKTSTOREFLAGS = 0x15;
    axradio_setaddrregs();
}





static void axradio_sync_addtime(uint32_t dt) __reentrant
{
    axradio_sync_time += dt;
}

static void axradio_sync_subtime(uint32_t dt) __reentrant
{
    axradio_sync_time -= dt;
}

static void axradio_sync_settimeradv(uint32_t dt) __reentrant
{
    axradio_timer.time = axradio_sync_time;
    axradio_timer.time -= dt;
}

static void axradio_sync_adjustperiodcorr(void)
{
    int32_t __data dt = axradio_conv_time_totimer0(axradio_cb_receive.st.time.t) - axradio_sync_time;
    axradio_cb_receive.st.rx.phy.timeoffset = dt;
    if (!checksignedlimit16(axradio_sync_periodcorr, axradio_sync_slave_maxperiod)) {
        axradio_sync_addtime(dt);
        dt <<= 5;
        axradio_sync_periodcorr = dt;
    } else {
        axradio_sync_periodcorr += dt;
        dt >>= 2;
        axradio_sync_addtime(dt);
    }
    axradio_sync_periodcorr = signedlimit16(axradio_sync_periodcorr, axradio_sync_slave_maxperiod);
}

static void axradio_sync_slave_nextperiod()
{
    axradio_sync_addtime(axradio_sync_period);
    if (!checksignedlimit16(axradio_sync_periodcorr, axradio_sync_slave_maxperiod))
        return;
    {
        int16_t __data c = axradio_sync_periodcorr;
        axradio_sync_addtime(c >> 5);
    }
}



static void axradio_timer_callback(struct wtimer_desc __xdata *desc)
{
    desc;
    switch (axradio_mode) {
    case 0x1c:
    case 0x1d:
    case 0x1e:
    case 0x18:
    case 0x19:
        if (axradio_syncstate == syncstate_asynctx)
            goto transmitcs;
        wtimer_remove(&axradio_timer);
    rearmcstimer:
        axradio_timer.time = axradio_phy_cs_period;
        wtimer0_addrelative(&axradio_timer);
    chanstatecb:
        update_timeanchor();
        wtimer_remove_callback(&axradio_cb_channelstate.cb);
        axradio_cb_channelstate.st.error = 0x00;
        {
            int8_t __data r = AX5043_RSSI;
            axradio_cb_channelstate.st.cs.rssi = r - (int16_t)axradio_phy_rssioffset;
            axradio_cb_channelstate.st.cs.busy = r >= axradio_phy_channelbusy;
        }
        axradio_cb_channelstate.st.time.t = axradio_timeanchor.radiotimer;
        wtimer_add_callback(&axradio_cb_channelstate.cb);
        break;

    case 0x10:
    case 0x11:
    transmitcs:
        if (axradio_ack_count)
            --axradio_ack_count;
        wtimer_remove(&axradio_timer);
        if ((int8_t)AX5043_RSSI < axradio_phy_channelbusy ||
            (!axradio_ack_count && axradio_phy_lbt_forcetx)) {
            axradio_syncstate = syncstate_off;
            axradio_txbuffer_cnt = axradio_phy_preamble_longlen;
            ax5043_prepare_tx();
            goto chanstatecb;
        }
        if (axradio_ack_count)
            goto rearmcstimer;
        update_timeanchor();
        axradio_syncstate = syncstate_off;
        ax5043_off();
        wtimer_remove_callback(&axradio_cb_transmitstart.cb);
        axradio_cb_transmitstart.st.error = 0x03;
        axradio_cb_transmitstart.st.time.t = axradio_timeanchor.radiotimer;
        wtimer_add_callback(&axradio_cb_transmitstart.cb);
        break;

    case 0x12:
    case 0x13:
        if (axradio_syncstate == syncstate_lbt)
            goto transmitcs;
        ax5043_off();
        if (!axradio_ack_count) {
            update_timeanchor();
            wtimer_remove_callback(&axradio_cb_transmitend.cb);
            axradio_cb_transmitend.st.error = 0x03;
            axradio_cb_transmitend.st.time.t = axradio_timeanchor.radiotimer;
            wtimer_add_callback(&axradio_cb_transmitend.cb);
            break;
        }
        --axradio_ack_count;
        axradio_txbuffer_cnt = axradio_phy_preamble_longlen;
        ax5043_prepare_tx();
        break;

    case 0x1a:
    case 0x1b:
        if (axradio_syncstate == syncstate_lbt)
            goto transmitcs;
    transmitack:
        AX5043_FIFOSTAT = 3;
        AX5043_PWRMODE = 0xd;
        while (!(AX5043_POWSTAT & 0x08));
        ax5043_init_registers_tx();
        AX5043_RADIOEVENTREQ0;
        AX5043_FIFOTHRESH1 = 0;
        AX5043_FIFOTHRESH0 = 0x80;
        axradio_trxstate = trxstate_tx_longpreamble;
        axradio_txbuffer_cnt = axradio_phy_preamble_longlen;

        if ((AX5043_MODULATION & 0x0F) == 9) {
            AX5043_FIFODATA = 0x01 | (7 << 5);
            AX5043_FIFODATA = 2;
            AX5043_FIFODATA = 0x01;
            AX5043_FIFODATA = 0x11;
        }





        AX5043_IRQMASK0 = 0x08;
        update_timeanchor();
        wtimer_remove_callback(&axradio_cb_transmitstart.cb);
        axradio_cb_transmitstart.st.error = 0x00;
        axradio_cb_transmitstart.st.time.t = axradio_timeanchor.radiotimer;
        wtimer_add_callback(&axradio_cb_transmitstart.cb);
        break;

    case 0x20:
    case 0x21:
        switch (axradio_syncstate) {
        default:
            AX5043_PWRMODE = 0x5;
            ax5043_init_registers_tx();
            axradio_syncstate = syncstate_master_xostartup;
            wtimer_remove_callback(&axradio_cb_transmitdata.cb);
            axradio_cb_transmitdata.st.error = 0x00;
            axradio_cb_transmitdata.st.time.t = 0;
            wtimer_add_callback(&axradio_cb_transmitdata.cb);
            wtimer_remove(&axradio_timer);
            axradio_timer.time = axradio_sync_time;
            wtimer0_addabsolute(&axradio_timer);
            break;

        case syncstate_master_xostartup:
            AX5043_FIFOSTAT = 3;
            AX5043_PWRMODE = 0xd;
            while (!(AX5043_POWSTAT & 0x08));
            AX5043_RADIOEVENTREQ0;
            AX5043_FIFOTHRESH1 = 0;
            AX5043_FIFOTHRESH0 = 0x80;
            axradio_trxstate = trxstate_tx_longpreamble;
            axradio_txbuffer_cnt = axradio_phy_preamble_longlen;

            if ((AX5043_MODULATION & 0x0F) == 9) {
                AX5043_FIFODATA = 0x01 | (7 << 5);
                AX5043_FIFODATA = 2;
                AX5043_FIFODATA = 0x01;
                AX5043_FIFODATA = 0x11;
            }





            wtimer_remove(&axradio_timer);
            update_timeanchor();
            AX5043_IRQMASK0 = 0x08;
            axradio_sync_addtime(axradio_sync_period);
            axradio_syncstate = syncstate_master_waitack;
            if (axradio_mode != 0x21) {
                axradio_syncstate = syncstate_master_normal;
                axradio_sync_settimeradv(axradio_sync_xoscstartup);
                wtimer0_addabsolute(&axradio_timer);
            }
            wtimer_remove_callback(&axradio_cb_transmitstart.cb);
            axradio_cb_transmitstart.st.error = 0x00;
            axradio_cb_transmitstart.st.time.t = axradio_timeanchor.radiotimer;
            wtimer_add_callback(&axradio_cb_transmitstart.cb);
            break;

        case syncstate_master_waitack:
            ax5043_off();
            axradio_syncstate = syncstate_master_normal;
            wtimer_remove(&axradio_timer);
            axradio_sync_settimeradv(axradio_sync_xoscstartup);
            wtimer0_addabsolute(&axradio_timer);
            update_timeanchor();
            wtimer_remove_callback(&axradio_cb_transmitend.cb);
            axradio_cb_transmitend.st.error = 0x03;
            axradio_cb_transmitend.st.time.t = axradio_timeanchor.radiotimer;
            wtimer_add_callback(&axradio_cb_transmitend.cb);
            break;
        };
        break;

    case 0x22:
    case 0x23:
        switch (axradio_syncstate) {
        default:
        case syncstate_slave_synchunt:
            ax5043_off();
            axradio_syncstate = syncstate_slave_syncpause;
            axradio_sync_addtime(axradio_sync_slave_syncpause);
            wtimer_remove(&axradio_timer);
            axradio_timer.time = axradio_sync_time;
            wtimer0_addabsolute(&axradio_timer);
            wtimer_remove_callback(&axradio_cb_receive.cb);
            memset(&axradio_cb_receive.st, 0, sizeof(axradio_cb_receive.st));
            axradio_cb_receive.st.time.t = axradio_timeanchor.radiotimer;
            axradio_cb_receive.st.error = 0x0a;
            wtimer_add_callback(&axradio_cb_receive.cb);
            break;

        case syncstate_slave_syncpause:
            ax5043_receiver_on_continuous();
            axradio_syncstate = syncstate_slave_synchunt;
            axradio_sync_addtime(axradio_sync_slave_syncwindow);
            wtimer_remove(&axradio_timer);
            axradio_timer.time = axradio_sync_time;
            wtimer0_addabsolute(&axradio_timer);
            update_timeanchor();
            wtimer_remove_callback(&axradio_cb_receive.cb);
            memset(&axradio_cb_receive.st, 0, sizeof(axradio_cb_receive.st));
            axradio_cb_receive.st.time.t = axradio_timeanchor.radiotimer;
            axradio_cb_receive.st.error = 0x09;
            wtimer_add_callback(&axradio_cb_receive.cb);
            break;

        case syncstate_slave_rxidle:
            AX5043_PWRMODE = 0x5;
            axradio_syncstate = syncstate_slave_rxxosc;
            wtimer_remove(&axradio_timer);
            axradio_timer.time += axradio_sync_xoscstartup;
            wtimer0_addabsolute(&axradio_timer);
            break;

        case syncstate_slave_rxxosc:
            ax5043_receiver_on_continuous();
            axradio_syncstate = syncstate_slave_rxsfdwindow;
            update_timeanchor();
            wtimer_remove_callback(&axradio_cb_receive.cb);
            memset(&axradio_cb_receive.st, 0, sizeof(axradio_cb_receive.st));
            axradio_cb_receive.st.time.t = axradio_timeanchor.radiotimer;
            axradio_cb_receive.st.error = 0x0b;
            wtimer_add_callback(&axradio_cb_receive.cb);
            wtimer_remove(&axradio_timer);
            {
                uint8_t __data idx = axradio_ack_seqnr;
                if (idx >= axradio_sync_slave_nrrx)
                    idx = axradio_sync_slave_nrrx - 1;
                axradio_timer.time += axradio_sync_slave_rxwindow[idx];
            }
            wtimer0_addabsolute(&axradio_timer);
            break;

        case syncstate_slave_rxsfdwindow:
            if (!(0x0F & (uint8_t)~AX5043_RADIOSTATE)) {
                axradio_syncstate = syncstate_slave_rxpacket;
                wtimer_remove(&axradio_timer);
                axradio_timer.time += axradio_sync_slave_rxtimeout;
                wtimer0_addabsolute(&axradio_timer);
                break;
            }


        case syncstate_slave_rxpacket:
            ax5043_off();
            if (!axradio_ack_seqnr)
                axradio_ack_seqnr = 1;
            ++axradio_ack_seqnr;
            update_timeanchor();
            wtimer_remove_callback(&axradio_cb_receive.cb);
            memset(&axradio_cb_receive.st, 0, sizeof(axradio_cb_receive.st));
            axradio_cb_receive.st.time.t = axradio_timeanchor.radiotimer;
            axradio_cb_receive.st.error = 0x03;
            if (axradio_ack_seqnr <= axradio_sync_slave_resyncloss) {
                wtimer_add_callback(&axradio_cb_receive.cb);
                axradio_sync_slave_nextperiod();
                axradio_syncstate = syncstate_slave_rxidle;
                wtimer_remove(&axradio_timer);
                {
                    uint8_t __data idx = axradio_ack_seqnr;
                    if (idx >= axradio_sync_slave_nrrx)
                        idx = axradio_sync_slave_nrrx - 1;
                    axradio_sync_settimeradv(axradio_sync_slave_rxadvance[idx]);
                }
                wtimer0_addabsolute(&axradio_timer);
                break;
            }
            axradio_cb_receive.st.error = 0x09;
            wtimer_add_callback(&axradio_cb_receive.cb);
            ax5043_receiver_on_continuous();
            axradio_syncstate = syncstate_slave_synchunt;
            wtimer_remove(&axradio_timer);
            axradio_timer.time = axradio_sync_slave_syncwindow;
            wtimer0_addrelative(&axradio_timer);
            axradio_sync_time = axradio_timer.time;
            break;

        case syncstate_slave_rxack:
            axradio_syncstate = syncstate_slave_rxidle;
            wtimer_remove(&axradio_timer);
            axradio_sync_settimeradv(axradio_sync_slave_rxadvance[1]);
            wtimer0_addabsolute(&axradio_timer);
            goto transmitack;
        };
        break;

    default:
        break;
    }
}

static void axradio_callback_fwd(struct wtimer_callback __xdata *desc) __reentrant
{
    axradio_statuschange((struct axradio_status __xdata *)(desc + 1));
}

static void axradio_receive_callback_fwd(struct wtimer_callback __xdata *desc)
{

    desc;






    if (axradio_cb_receive.st.error != 0x00) {
        axradio_statuschange((struct axradio_status __xdata *)&axradio_cb_receive.st);
        return;
    }
    if (axradio_phy_pn9 && !(axradio_mode == 0x1c ||
                             axradio_mode == 0x1d ||
                             axradio_mode == 0x1e)) {
        uint16_t __data len = axradio_cb_receive.st.rx.pktlen;
        len += axradio_framing_maclen;
        pn9_buffer((__xdata uint8_t *)axradio_cb_receive.st.rx.mac.raw, len, 0x1ff, -(AX5043_ENCODING & 0x01));
    }
    if (axradio_framing_swcrclen && !(axradio_mode == 0x1c ||
                                      axradio_mode == 0x1d ||
                                      axradio_mode == 0x1e)) {
        uint16_t __data len = axradio_cb_receive.st.rx.pktlen;
        len += axradio_framing_maclen;
        if (!axradio_framing_check_crc((__xdata uint8_t *)axradio_cb_receive.st.rx.mac.raw, len)) {

            goto endcb;
        }
        axradio_cb_receive.st.rx.pktlen -= axradio_framing_swcrclen;
    }


    axradio_cb_receive.st.rx.phy.timeoffset = 0;
    axradio_cb_receive.st.rx.phy.period = 0;
    if (axradio_mode == 0x12 ||
        axradio_mode == 0x13 ||
        axradio_mode == 0x21) {
        ax5043_off();
        wtimer_remove(&axradio_timer);
        if (axradio_mode == 0x21) {
            axradio_syncstate = syncstate_master_normal;
            axradio_sync_settimeradv(axradio_sync_xoscstartup);
            wtimer0_addabsolute(&axradio_timer);
        }
        wtimer_remove_callback(&axradio_cb_transmitend.cb);
        axradio_cb_transmitend.st.error = 0x00;
        axradio_cb_transmitend.st.time.t = radio_read24((uint16_t)&AX5043_TIMER2);
        wtimer_add_callback(&axradio_cb_transmitend.cb);
    }
    if (axradio_framing_destaddrpos != 0xff)
        memcpy(&axradio_cb_receive.st.rx.mac.localaddr, &axradio_cb_receive.st.rx.mac.raw[axradio_framing_destaddrpos], axradio_framing_addrlen);
    if (axradio_framing_sourceaddrpos != 0xff)
        memcpy(&axradio_cb_receive.st.rx.mac.remoteaddr, &axradio_cb_receive.st.rx.mac.raw[axradio_framing_sourceaddrpos], axradio_framing_addrlen);
    if (axradio_mode == 0x1a ||
        axradio_mode == 0x1b ||
        axradio_mode == 0x23) {
        axradio_ack_count = 0;
        axradio_txbuffer_len = axradio_framing_maclen + axradio_framing_minpayloadlen;
        memset(axradio_txbuffer, 0, axradio_framing_maclen);
        if (axradio_framing_ack_seqnrpos != 0xff) {
            uint8_t seqnr = axradio_cb_receive.st.rx.mac.raw[axradio_framing_ack_seqnrpos];
            axradio_txbuffer[axradio_framing_ack_seqnrpos] = seqnr;
            if (axradio_ack_seqnr != seqnr)
                axradio_ack_seqnr = seqnr;
            else
                axradio_cb_receive.st.error = 0x08;
        }
        if (axradio_framing_destaddrpos != 0xff) {
            if (axradio_framing_sourceaddrpos != 0xff)
                memcpy(&axradio_txbuffer[axradio_framing_destaddrpos], &axradio_cb_receive.st.rx.mac.remoteaddr, axradio_framing_addrlen);
            else
                memcpy(&axradio_txbuffer[axradio_framing_destaddrpos], &axradio_default_remoteaddr, axradio_framing_addrlen);
        }
        if (axradio_framing_sourceaddrpos != 0xff)
            memcpy(&axradio_txbuffer[axradio_framing_sourceaddrpos], &axradio_localaddr.addr, axradio_framing_addrlen);
        if (axradio_framing_lenmask) {
            uint8_t len_byte = (uint8_t)(axradio_txbuffer_len - axradio_framing_lenoffs) & axradio_framing_lenmask;
            axradio_txbuffer[axradio_framing_lenpos] = (axradio_txbuffer[axradio_framing_lenpos] & (uint8_t)~axradio_framing_lenmask) | len_byte;
        }
        if (axradio_framing_swcrclen) {
            axradio_framing_append_crc(axradio_txbuffer, axradio_txbuffer_len);
            axradio_txbuffer_len += axradio_framing_swcrclen;
        }
        if (axradio_phy_pn9) {
            pn9_buffer(axradio_txbuffer, axradio_txbuffer_len, 0x1ff, -(AX5043_ENCODING & 0x01));
        }
        AX5043_IRQMASK1 = 0x00;
        AX5043_IRQMASK0 = 0x00;
        AX5043_PWRMODE = 0x5;
        AX5043_FIFOSTAT = 3;
        axradio_trxstate = trxstate_tx_longpreamble;
        while (AX5043_POWSTAT & 0x08);
        wtimer_remove(&axradio_timer);
        axradio_timer.time = axradio_framing_ack_delay;
        wtimer1_addrelative(&axradio_timer);
    }
    if (axradio_mode == 0x22 ||
        axradio_mode == 0x23) {
        if (axradio_mode != 0x23)
            ax5043_off();
        switch (axradio_syncstate) {
        default:


            axradio_sync_time = axradio_conv_time_totimer0(axradio_cb_receive.st.time.t);
            axradio_sync_periodcorr = -32768;
            axradio_ack_seqnr = 0;
            break;

        case syncstate_slave_rxidle:
        case syncstate_slave_rxsfdwindow:
        case syncstate_slave_rxpacket:
            axradio_sync_adjustperiodcorr();
            axradio_cb_receive.st.rx.phy.period = axradio_sync_periodcorr >> 5;
            axradio_ack_seqnr = 1;
            break;
        };
        axradio_sync_slave_nextperiod();
        if (axradio_mode != 0x23) {
            axradio_syncstate = syncstate_slave_rxidle;
            wtimer_remove(&axradio_timer);
            axradio_sync_settimeradv(axradio_sync_slave_rxadvance[axradio_ack_seqnr]);
            wtimer0_addabsolute(&axradio_timer);
        } else {
            axradio_syncstate = syncstate_slave_rxack;
        }
    }
    axradio_statuschange((struct axradio_status __xdata *)&axradio_cb_receive.st);
endcb:
    if (axradio_mode == 0x19) {
        ax5043_receiver_on_wor();
    } else if (axradio_mode == 0x1a ||
               axradio_mode == 0x1b) {
        uint8_t __data trxst;
        {
            uint8_t __data iesave = IE & 0x80;
            EA = 0;
            trxst = axradio_trxstate;
            axradio_cb_receive.st.error = 0xf0;
            IE |= iesave;
        }
        if (trxst == trxstate_off) {
                if (axradio_mode == 0x1b)
                    ax5043_receiver_on_wor();
                else
                    ax5043_receiver_on_continuous();
        }
    } else {
        switch (axradio_trxstate) {
        case trxstate_rx:
        case trxstate_rxwor:
            AX5043_IRQMASK0 |= 0x01;
            break;

        default:
            break;
        }
    }
}

static void axradio_killallcb(void)
{
    wtimer_remove_callback(&axradio_cb_receive.cb);
    wtimer_remove_callback(&axradio_cb_receivesfd.cb);
    wtimer_remove_callback(&axradio_cb_channelstate.cb);
    wtimer_remove_callback(&axradio_cb_transmitstart.cb);
    wtimer_remove_callback(&axradio_cb_transmitend.cb);
    wtimer_remove_callback(&axradio_cb_transmitdata.cb);
    wtimer_remove(&axradio_timer);
}





uint8_t axradio_init(void)
{
    uint8_t __data i, pllloop_save, pllcpi_save;
    axradio_mode = 0x00;
    axradio_killallcb();
    axradio_cb_receive.cb.handler = axradio_receive_callback_fwd;
    axradio_cb_receive.st.status = 0x00;
    memset(axradio_cb_receive.st.rx.mac.remoteaddr, 0, sizeof(axradio_cb_receive.st.rx.mac.remoteaddr));
    memset(axradio_cb_receive.st.rx.mac.localaddr, 0, sizeof(axradio_cb_receive.st.rx.mac.localaddr));
    axradio_cb_receivesfd.cb.handler = axradio_callback_fwd;
    axradio_cb_receivesfd.st.status = 0x01;
    axradio_cb_channelstate.cb.handler = axradio_callback_fwd;
    axradio_cb_channelstate.st.status = 0x02;
    axradio_cb_transmitstart.cb.handler = axradio_callback_fwd;
    axradio_cb_transmitstart.st.status = 0x03;
    axradio_cb_transmitend.cb.handler = axradio_callback_fwd;
    axradio_cb_transmitend.st.status = 0x04;
    axradio_cb_transmitdata.cb.handler = axradio_callback_fwd;
    axradio_cb_transmitdata.st.status = 0x05;
    axradio_timer.handler = axradio_timer_callback;
    axradio_curchannel = 0;
    axradio_curfreqoffset = 0;
    IE_4 = 0;
    axradio_trxstate = trxstate_off;
    if (ax5043_reset())
        return 0x05;
    ax5043_init_registers();
    ax5043_set_registers_rx();
    pllloop_save = AX5043_PLLLOOP;
    pllcpi_save = AX5043_PLLCPI;
    AX5043_PLLLOOP = 0x09;
    AX5043_PLLCPI = 0x08;

    IE_4 = 1;

    AX5043_PWRMODE = 0x5;
    axradio_wait_for_xtal();

    for (i = 0; i < axradio_phy_nrchannels; ++i) {
        uint8_t __data iesave;
        {
            uint32_t __data f = axradio_phy_chanfreq[i];
            AX5043_FREQA0 = f;
            AX5043_FREQA1 = f >> 8;
            AX5043_FREQA2 = f >> 16;
            AX5043_FREQA3 = f >> 24;
        }
        iesave = IE & 0x80;
        EA = 0;
        axradio_trxstate = trxstate_pll_ranging;
        AX5043_IRQMASK1 = 0x10;
        {
            uint8_t __data r;
            if( !(axradio_phy_chanpllrnginit[0] & 0xF0) ) {
                r = axradio_phy_chanpllrnginit[i] | 0x10;
            }
            else {
                r = 0x18;
                if (i) {
                    r = axradio_phy_chanpllrng_rx[i - 1];
                    if (r & 0x20)
                        r = 0x08;
                    r &= 0x0F;
                    r |= 0x10;
                }
            }
            AX5043_PLLRANGINGA = r;
        }
        for (;;) {
            EA = 0;
            if (axradio_trxstate == trxstate_pll_ranging_done)
                break;
            wtimer_idle(0x02);
            IE |= iesave;
            wtimer_runcallbacks();
        }
        axradio_trxstate = trxstate_off;
        AX5043_IRQMASK1 = 0x00;
        axradio_phy_chanpllrng_rx[i] = AX5043_PLLRANGINGA;
        IE |= iesave;
    }
    ax5043_set_registers_tx();
    AX5043_PLLLOOP = 0x09;
    AX5043_PLLCPI = 0x08;
    for (i = 0; i < axradio_phy_nrchannels; ++i) {
        uint8_t __data iesave = IE & 0x80;
        EA = 0;
        axradio_trxstate = trxstate_pll_ranging;
        AX5043_IRQMASK1 = 0x10;
        {
            uint8_t __data r;
            if( !(axradio_phy_chanpllrnginit[0] & 0xF0) ) {
                r = axradio_phy_chanpllrnginit[i] | 0x10;
            }
            else {
                r = axradio_phy_chanpllrng_rx[i];
                if (r & 0x20)
                    r = 0x08;
                r &= 0x0F;
                r |= 0x10;
            }
            AX5043_PLLRANGINGA = r;
        }
        for (;;) {
            EA = 0;
            if (axradio_trxstate == trxstate_pll_ranging_done)
                break;
            wtimer_idle(0x02);
            IE |= iesave;
            wtimer_runcallbacks();
        }
        axradio_trxstate = trxstate_off;
        AX5043_IRQMASK1 = 0x00;
        axradio_phy_chanpllrng_tx[i] = AX5043_PLLRANGINGA;
        IE |= iesave;
    }
    AX5043_PWRMODE = 0x0;
    AX5043_PLLRANGINGA = axradio_phy_chanpllrng_rx[0] & 0x0F;
    {
        uint32_t __data f = axradio_phy_chanfreq[0];
        AX5043_FREQA0 = f;
        AX5043_FREQA1 = f >> 8;
        AX5043_FREQA2 = f >> 16;
        AX5043_FREQA3 = f >> 24;
    }
    AX5043_PLLLOOP = pllloop_save;
    AX5043_PLLCPI = pllcpi_save;

    axradio_mode = 0x01;
    for (i = 0; i < axradio_phy_nrchannels; ++i)
        if ((axradio_phy_chanpllrng_rx[i] | axradio_phy_chanpllrng_tx[i]) & 0x20)
            return 0x06;

    return 0x00;
}

 uint8_t axradio_cansleep(void) __reentrant
{
    if (axradio_trxstate == trxstate_off || axradio_trxstate == trxstate_rxwor)
        return 1;
    return 0;
}


static void wtimer_cansleep_dummy(void) __naked
{
        __asm
        .area WTCANSLP0 (CODE)
        .area WTCANSLP1 (CODE)
        .area WTCANSLP2 (CODE)

        .area WTCANSLP1 (CODE)
        lcall _axradio_cansleep
        mov a,dpl
        jnz 00000$
        ret
00000$:
        .area CSEG (CODE)
        __endasm;
}


uint8_t axradio_set_mode(uint8_t mode)
{
    if (mode == axradio_mode)
        return 0x00;
    switch (axradio_mode) {
    case 0x00:
    {
        uint8_t __data r = axradio_init();
        if (r != 0x00)
            return r;
        break;
    }

    case 0x02:
    {
        uint8_t __data r = ax5043_wakeup_deepsleep();
        if (r)
            return 0x05;
        ax5043_init_registers();
        r = axradio_set_channel(axradio_curchannel);
        if (r != 0x00)
            return r;
        axradio_trxstate = trxstate_off;
        axradio_mode = 0x01;
        break;
    }

    case 0x14:
    case 0x15:
    case 0x16:
    case 0x03:
    {
        uint8_t __data iesave = IE & 0x80;
        EA = 0;
        if (axradio_trxstate == trxstate_off) {
            update_timeanchor();
            wtimer_remove_callback(&axradio_cb_transmitend.cb);
            axradio_cb_transmitend.st.error = 0x00;
            axradio_cb_transmitend.st.time.t = axradio_timeanchor.radiotimer;
            wtimer_add_callback(&axradio_cb_transmitend.cb);
        }
        ax5043_off();
        IE |= iesave;

        ax5043_init_registers();
        axradio_mode = 0x01;
        break;
    }

    case 0x1c:
    case 0x1d:
    case 0x1e:
        ax5043_off();
        ax5043_init_registers();
        axradio_mode = 0x01;

    default:
        ax5043_off();
        axradio_mode = 0x01;
        break;
    }
    axradio_killallcb();
    if (mode == 0x00)
        return 0x01;
    axradio_syncstate = syncstate_off;
    switch (mode) {
    case 0x01:
        return 0x00;

    case 0x02:
        ax5043_enter_deepsleep();
        axradio_mode = 0x02;
        return 0x00;

    case 0x10:
    case 0x12:
        ax5043_init_registers_tx();
        axradio_ack_seqnr = 0xff;
        axradio_mode = mode;
        return 0x00;

    case 0x11:
    case 0x13:
        ax5043_init_registers_tx();
        axradio_ack_seqnr = 0xff;
        axradio_mode = mode;
        return 0x00;

    case 0x18:
    case 0x1a:
        ax5043_init_registers_rx();
        ax5043_receiver_on_continuous();
        axradio_ack_seqnr = 0xff;
        axradio_mode = mode;
    enablecs:
        if (axradio_phy_cs_enabled) {
            wtimer_remove(&axradio_timer);
            axradio_timer.time = axradio_phy_cs_period;
            wtimer0_addrelative(&axradio_timer);
        }
        return 0x00;

    case 0x19:
    case 0x1b:
        ax5043_init_registers_rx();
        ax5043_receiver_on_wor();
        axradio_ack_seqnr = 0xff;
        axradio_mode = mode;
        return 0x00;

    case 0x14:
    case 0x15:
    case 0x16:
        axradio_mode = mode;
        if (axradio_mode == 0x15)
            AX5043_ENCODING = 0;
        if (axradio_mode == 0x16)
            AX5043_ENCODING = 4;
        ax5043_init_registers_tx();
        AX5043_FRAMING = 0;
        ax5043_prepare_tx();
        axradio_trxstate = trxstate_txstream_xtalwait;
        while (!(AX5043_POWSTAT & 0x08)) {};
        AX5043_FIFOSTAT = 3;
        AX5043_RADIOEVENTREQ0;
        update_timeanchor();
        wtimer_remove_callback(&axradio_cb_transmitdata.cb);
        axradio_cb_transmitdata.st.error = 0x00;
        axradio_cb_transmitdata.st.time.t = axradio_timeanchor.radiotimer;
        wtimer_add_callback(&axradio_cb_transmitdata.cb);
        return 0x00;

    case 0x1c:
    case 0x1d:
    case 0x1e:
        ax5043_init_registers_rx();
        if (axradio_mode == 0x1d)
            AX5043_ENCODING = 0;
        if (axradio_mode == 0x1e)
            AX5043_ENCODING = 4;
        AX5043_FRAMING = 0;
        AX5043_PKTCHUNKSIZE = 8;
        AX5043_RXPARAMSETS = 0x00;
        axradio_mode = mode;
        ax5043_receiver_on_continuous();
        goto enablecs;

    case 0x03:
        ax5043_init_registers_tx();
        AX5043_MODULATION = 8;
        AX5043_FSKDEV2 = 0x00;
        AX5043_FSKDEV1 = 0x00;
        AX5043_FSKDEV0 = 0x00;
        AX5043_TXRATE2 = 0x00;
        AX5043_TXRATE1 = 0x00;
        AX5043_TXRATE0 = 0x01;
        AX5043_PINFUNCDATA = 0x04;
        axradio_mode = 0x03;
        AX5043_PWRMODE = 0x7;
        axradio_trxstate = trxstate_txcw_xtalwait;
        AX5043_IRQMASK0 = 0x00;
        AX5043_IRQMASK1 = 0x01;
        return 0x00;

    case 0x20:
    case 0x21:
        axradio_mode = mode;
        axradio_syncstate = syncstate_master_normal;

        wtimer_remove(&axradio_timer);
        axradio_timer.time = 2;
        wtimer0_addrelative(&axradio_timer);
        axradio_sync_time = axradio_timer.time;
        axradio_sync_addtime(axradio_sync_xoscstartup);
        return 0x00;

    case 0x22:
    case 0x23:
        axradio_mode = mode;
        ax5043_init_registers_rx();
        ax5043_receiver_on_continuous();
        axradio_syncstate = syncstate_slave_synchunt;
        wtimer_remove(&axradio_timer);
        axradio_timer.time = axradio_sync_slave_initialsyncwindow;
        wtimer0_addrelative(&axradio_timer);
        axradio_sync_time = axradio_timer.time;
        wtimer_remove_callback(&axradio_cb_receive.cb);
        memset(&axradio_cb_receive.st, 0, sizeof(axradio_cb_receive.st));
        axradio_cb_receive.st.time.t = axradio_timeanchor.radiotimer;
        axradio_cb_receive.st.error = 0x09;
        wtimer_add_callback(&axradio_cb_receive.cb);
        return 0x00;

    default:
        return 0x01;
    }
}

uint8_t axradio_get_mode(void)
{
    return axradio_mode;
}

uint8_t axradio_set_channel(uint8_t chnum)
{
    uint8_t __data rng;
    if (chnum >= axradio_phy_nrchannels)
        return 0x04;
    axradio_curchannel = chnum;
    rng = axradio_phy_chanpllrng_rx[chnum];
    if (rng & 0x20)
        return 0x06;
    {
        uint32_t __data f = axradio_phy_chanfreq[chnum];
        f += axradio_curfreqoffset;
        if (AX5043_PLLLOOP & 0x80) {
            AX5043_PLLRANGINGA = rng & 0x0F;
            AX5043_FREQA0 = f;
            AX5043_FREQA1 = f >> 8;
            AX5043_FREQA2 = f >> 16;
            AX5043_FREQA3 = f >> 24;
        } else {
            AX5043_PLLRANGINGB = rng & 0x0F;
            AX5043_FREQB0 = f;
            AX5043_FREQB1 = f >> 8;
            AX5043_FREQB2 = f >> 16;
            AX5043_FREQB3 = f >> 24;
        }
    }
    AX5043_PLLLOOP ^= 0x80;
    return 0x00;
}

uint8_t axradio_get_channel(void)
{
    return axradio_curchannel;
}

uint8_t axradio_get_pllrange(void)
{
    return axradio_phy_chanpllrng_rx[axradio_curchannel] & 0x0F;
}

uint8_t axradio_get_pllrange_tx(void)
{
    return axradio_phy_chanpllrng_tx[axradio_curchannel] & 0x0F;
}

static uint8_t axradio_set_curfreqoffset(int32_t offs)
{
    axradio_curfreqoffset = offs;
    if (checksignedlimit32(offs, axradio_phy_maxfreqoffset))
        return 0x00;
    if (axradio_curfreqoffset < 0)
        axradio_curfreqoffset = -axradio_phy_maxfreqoffset;
    else
        axradio_curfreqoffset = axradio_phy_maxfreqoffset;
    return 0x04;
}

uint8_t axradio_set_freqoffset(int32_t offs)
{
    uint8_t __data ret = axradio_set_curfreqoffset(offs);
    {
        uint8_t __data ret2 = axradio_set_channel(axradio_curchannel);
        if (ret == 0x00)
            ret = ret2;
    }
    return ret;
}

int32_t axradio_get_freqoffset(void)
{
    return axradio_curfreqoffset;
}

void axradio_set_local_address(const struct axradio_address_mask *addr)
{
    memcpy(&axradio_localaddr, addr, sizeof(axradio_localaddr));
    axradio_setaddrregs();
}

void axradio_get_local_address(struct axradio_address_mask *addr)
{
    memcpy(addr, &axradio_localaddr, sizeof(axradio_localaddr));
}

void axradio_set_default_remote_address(const struct axradio_address *addr)
{
    memcpy(&axradio_default_remoteaddr, addr, sizeof(axradio_default_remoteaddr));
}

void axradio_get_default_remote_address(struct axradio_address *addr)
{
    memcpy(addr, &axradio_default_remoteaddr, sizeof(axradio_default_remoteaddr));
}

uint8_t axradio_transmit(const struct axradio_address *addr, const uint8_t *pkt, uint16_t pktlen)
{
    switch (axradio_mode) {
    case 0x14:
    case 0x15:
    case 0x16:
        {
            uint16_t __data fifofree = radio_read16((uint16_t)&AX5043_FIFOFREE1);
            if (fifofree < pktlen + 3)
                return 0x04;
        }
        if (pktlen) {
            uint8_t __data i = pktlen;
            AX5043_FIFODATA = 0x01 | (7 << 5);
            AX5043_FIFODATA = i + 1;
            AX5043_FIFODATA = 0x08;
            do {
                AX5043_FIFODATA = *pkt++;
            } while (--i);
        }
        AX5043_FIFOSTAT = 4;
        {
            uint8_t __data iesave = IE & 0x80;
            EA = 0;
            AX5043_IRQMASK0 |= 0x08;
            IE |= iesave;
        }
        return 0x00;

    case 0x20:
    case 0x21:
        goto dotx;

    case 0x18:
    case 0x19:
        if (axradio_syncstate != syncstate_off)
            return 0x02;
        AX5043_IRQMASK1 = 0x00;
        AX5043_IRQMASK0 = 0x00;
        AX5043_PWRMODE = 0x5;
        AX5043_FIFOSTAT = 3;
        while (AX5043_POWSTAT & 0x08);
        ax5043_init_registers_tx();
        goto dotx;

    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
        if (axradio_syncstate != syncstate_off)
            return 0x02;
    dotx:
        axradio_ack_count = axradio_framing_ack_retransmissions;
        ++axradio_ack_seqnr;
        axradio_txbuffer_len = pktlen + axradio_framing_maclen;
        if (axradio_txbuffer_len > sizeof(axradio_txbuffer))
            return 0x04;
        memset(axradio_txbuffer, 0, axradio_framing_maclen);
        memcpy(&axradio_txbuffer[axradio_framing_maclen], pkt, pktlen);
        if (axradio_framing_ack_seqnrpos != 0xff)
            axradio_txbuffer[axradio_framing_ack_seqnrpos] = axradio_ack_seqnr;
        if (axradio_framing_destaddrpos != 0xff)
            memcpy(&axradio_txbuffer[axradio_framing_destaddrpos], &addr->addr, axradio_framing_addrlen);
        if (axradio_framing_sourceaddrpos != 0xff)
            memcpy(&axradio_txbuffer[axradio_framing_sourceaddrpos], &axradio_localaddr.addr, axradio_framing_addrlen);
        if (axradio_framing_lenmask) {
            uint8_t __data len_byte = (uint8_t)(axradio_txbuffer_len - axradio_framing_lenoffs) & axradio_framing_lenmask;
            axradio_txbuffer[axradio_framing_lenpos] = (axradio_txbuffer[axradio_framing_lenpos] & (uint8_t)~axradio_framing_lenmask) | len_byte;
        }
        if (axradio_framing_swcrclen) {
            axradio_framing_append_crc(axradio_txbuffer, axradio_txbuffer_len);
            axradio_txbuffer_len += axradio_framing_swcrclen;
        }
        if (axradio_phy_pn9)
            pn9_buffer(axradio_txbuffer, axradio_txbuffer_len, 0x1ff, -(AX5043_ENCODING & 0x01));
        if (axradio_mode == 0x20 ||
            axradio_mode == 0x21)
            return 0x00;
        if (axradio_mode == 0x11 ||
            axradio_mode == 0x13)
            axradio_txbuffer_cnt = axradio_phy_preamble_wor_longlen;
        else
            axradio_txbuffer_cnt = axradio_phy_preamble_longlen;
        if (axradio_phy_lbt_retries) {
            switch (axradio_mode) {
            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x19:
            case 0x1b:
            case 0x18:
            case 0x1a:
                ax5043_off_xtal();
                ax5043_init_registers_rx();
                AX5043_RSSIREFERENCE = axradio_phy_rssireference;
                AX5043_PWRMODE = 0x9;
                axradio_ack_count = axradio_phy_lbt_retries;
                axradio_syncstate = syncstate_lbt;
                wtimer_remove(&axradio_timer);
                axradio_timer.time = axradio_phy_cs_period;
                wtimer0_addrelative(&axradio_timer);
                return 0x00;

            default:
                break;
            }
        }
        axradio_syncstate = syncstate_asynctx;
        ax5043_prepare_tx();
        return 0x00;

    default:
        return 0x01;
    }
}

static uint8_t axradio_set_paramsets(uint8_t val) __reentrant
{
    if (axradio_mode != 0x1c &&
        axradio_mode != 0x1d &&
        axradio_mode != 0x1e)
        return 0x01;
    AX5043_RXPARAMSETS = val;
    return 0x00;
}

uint8_t axradio_agc_freeze(void)
{
    return axradio_set_paramsets(0xff);
}

uint8_t axradio_agc_thaw(void)
{
    return axradio_set_paramsets(0x00);
}
